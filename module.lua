--[==[

	Simple Lua Bytecode Obfuscator

	This code is licensed under the MIT License.
	Copyright (c) 2023 Reboy / M0dder

	Made by Reboy / M0dder (Discord: kskreboy#4721)

	Supported Lua Versions:
	Lua 5.1+ / RBXLua (no loadstring)

	Features / How does it work:

	1. Convert to bytecode
	2. Encode bytecode to plain text
	3. Encrypt encoded code with random password
	* Minified code
	* Customizable variable name, variable comment, comment
	* Executable in Lua 5.1+ / RBXLua (no loadstring)
	+ new cli

	How to use / Example Usage:
	
	CLI Usage:
	
	Command (only --help for help):
	lua path/to/module.lua --source "<FILE_PATH>" --output "<NEWFILE_PATH>" [..]
	
	Example CLI:
	lua path/to/module.lua --source "C:\\mycode.lua" --output "result.lua" --comment "this code is obfuscated!"
	
	Lua Code:
	
	local module = require(path.to.module) -- this module, use require or dofile
	module(contents: string (source code), option table: { -- optional
		comment = "// comment", -- ex result: "--'comment'"
		variablecomment = "lol you have to stop trying to deobfuscate",
		cryptvarcomment = true, -- encrypt variablecomment with bytecode ex: "a" -> "\97"
		variablename = "CRYPTED", -- ex: "local 'variablename' = 'variablecomment'"
	}): string (obfuscated source code)
	
	Common Issue:
	lua has memory limit, so what do i do: Use luvi or srlua to convert obfuscator to binary application, limit will be up to 2gb.
	
	Example Lua Code:
	
	-- Obfuscate input.lua and write obfuscated code to result.lua
	local codefile, cerr = io.open("input.lua",'rb')
	local code
	if codefile then
		code = codefile:read("*a")
		codefile:close()
	else
		error(cerr)
	end
	local obfuscated = module(code)
	local resfile, rerr = io.open("result.lua",'w')
	if resfile then
		resfile:write(obfuscated)
		resfile:close()
	else
		print(rerr)
	end
	
	Credits:
	- FiOne LBI (created by same author as Rerubi) - https://github.com/Rerumu/FiOne
	- Yueliang 5 (Lua compiler in Lua) - http://yueliang.luaforge.net/
	- Moonshine (improved version of Yueliang) - https://github.com/gamesys/moonshine
	- ARCFOUR implementation in pure Lua - Rob Kendrick (rjek)

--]==]
local obversion = "v1.2"

-- check is this cli mode
local climode = arg ~= nil and true or false
local realargs = nil

if table.find == nil then
	table.find = function(tbl,value,pos)
		for i = pos or 1,#tbl do
			if tbl[i] == value then
				return i
			end
		end
	end
end

if climode == true then
	if #arg <= 1 and arg[1] == "--help" or arg[1] == "-h" or arg[1] == nil then
		print(
			"ByteLuaObfuscator " .. obversion .. "\n" ..
			"Copyright (c) 2023 Reboy / M0dder" .. "\n" ..
			"" .. "\n" ..
			"Usage:" .. "\n" ..
			"lua module.lua --source \"<FILE_PATH>\" --output \"<FILE_PATH>\" [..]" .. "\n" ..
			"" .. "\n" ..
			"Available Arguments:" .. "\n" ..
			"--help -h			Shows help.\n" ..
			"--source \"<FILE_PATH>\" 	Path to Lua script to obfuscate." .. "\n" ..
			"--output \"<FILE_PATH>\" 	Path to Lua script to output (document will be created if there isn't)." .. "\n" ..
			"--comment \"<COMMENT>\" 	Comment Option." .. "\n" ..
			"--varcomm \"<COMMENT>\" 	Comment Option for lua variable value." .. "\n" ..
			"--varname \"<STRING>\" 	Lua variable name (Special characters, spaces will be replaced with underline)." .. "\n" ..
			"--cryptvarcomm  	Encode (Decodable) comment for vartiable value." .. "\n" ..
			"" .. "\n"
		)
		return
	end
	realargs = {}
	local nextvargs = {"source","output","comment","varcomm","varname"}
	local skipdexes = {}
	for i,v in pairs(arg) do
		if (not table.find(skipdexes,i)) or (i > 0) then
			if v:sub(1,2) == "--" then
				if table.find(nextvargs,v:sub(3)) then
					realargs[v:sub(3)] = arg[i+1]
					table.insert(skipdexes,(#skipdexes+1),(i+1))
				else
					realargs[v:sub(3)] = true
				end
			end
		end
	end
end

local M = {}

local charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'--64
local morecharset = charset..'!@#$%&*()-=[];\'",./_+{}:|<>?'
local fenv = getfenv or function()
	return _ENV
end

local resources = {
	Yueliang = (function()local a={}local b={}local c={}local d={}local e={}local f={}local g=8;local function h(i)if not i then error("assertion failed!")end end;function a:make_getS(j)local k=j;return function()if not k then return nil end;local l=k;k=nil;return l end end;function a:make_getF(m)local n=512;local o=1;return function()local j=m:sub(o,o+n-1)o=math.min(#m+1,o+n)return j end end;function a:init(p,l)if not p then return end;local q={}q.reader=p;q.data=l or""q.name=name;if not l or l==""then q.n=0 else q.n=#l end;q.p=0;return q end;function a:fill(q)local j=q.reader()q.data=j;if not j or j==""then return"EOZ"end;q.n,q.p=#j-1,1;return string.sub(j,1,1)end;function a:zgetc(q)local r,s=q.n,q.p+1;if r>0 then q.n,q.p=r-1,s;return string.sub(q.data,s,s)else return self:fill(q)end end;c.RESERVED="TK_AND and\nTK_BREAK break\nTK_DO do\nTK_ELSE else\nTK_ELSEIF elseif\nTK_END end\nTK_FALSE false\nTK_FOR for\nTK_FUNCTION function\nTK_IF if\nTK_IN in\nTK_LOCAL local\nTK_NIL nil\nTK_NOT not\nTK_OR or\nTK_REPEAT repeat\nTK_RETURN return\nTK_THEN then\nTK_TRUE true\nTK_UNTIL until\nTK_WHILE while\nTK_CONCAT ..\nTK_DOTS ...\nTK_EQ ==\nTK_GE >=\nTK_LE <=\nTK_NE ~=\nTK_NAME <name>\nTK_NUMBER <number>\nTK_STRING <string>\nTK_EOS <eof>"c.MAXSRC=80;c.MAX_INT=2147483645;c.LUA_QS="'%s'"c.LUA_COMPAT_LSTR=1;function c:init()local t,u={},{}for v in string.gmatch(self.RESERVED,"[^\n]+")do local w,w,y,z=string.find(v,"(%S+)%s+(%S+)")t[y]=z;u[z]=y end;self.tokens=t;self.enums=u end;function c:chunkid(m,A)local B;local C=string.sub(m,1,1)if C=="="then B=string.sub(m,2,A)else if C=="@"then m=string.sub(m,2)A=A-#" '...' "local D=#m;B=""if D>A then m=string.sub(m,1+D-A)B=B.."..."end;B=B..m else local E=string.find(m,"[\n\r]")E=E and E-1 or#m;A=A-#" [string \"...\"] "if E>A then E=A end;B="[string \""if E<#m then B=B..string.sub(m,1,E).."..."else B=B..m end;B=B.."\"]"end end;return B end;function c:token2str(F,G)if string.sub(G,1,3)~="TK_"then if string.find(G,"%c")then return string.format("char(%d)",string.byte(G))end;return G else return self.tokens[G]end end;function c:lexerror(F,H,G)local function I(F,G)if G=="TK_NAME"or G=="TK_STRING"or G=="TK_NUMBER"then return F.buff else return self:token2str(F,G)end end;local j=self:chunkid(F.source,self.MAXSRC)local H=string.format("%s:%d: %s",j,F.linenumber,H)if G then H=string.format("%s near "..self.LUA_QS,H,I(F,G))end;error(H)end;function c:syntaxerror(F,H)self:lexerror(F,H,F.t.token)end;function c:currIsNewline(F)return F.current=="\n"or F.current=="\r"end;function c:inclinenumber(F)local J=F.current;self:nextc(F)if self:currIsNewline(F)and F.current~=J then self:nextc(F)end;F.linenumber=F.linenumber+1;if F.linenumber>=self.MAX_INT then self:syntaxerror(F,"chunk has too many lines")end end;function c:setinput(K,F,q,m)if not F then F={}end;if not F.lookahead then F.lookahead={}end;if not F.t then F.t={}end;F.decpoint="."F.L=K;F.lookahead.token="TK_EOS"F.z=q;F.fs=nil;F.linenumber=1;F.lastline=1;F.source=m;self:nextc(F)end;function c:check_next(F,L)if not string.find(L,F.current,1,1)then return false end;self:save_and_next(F)return true end;function c:next(F)F.lastline=F.linenumber;if F.lookahead.token~="TK_EOS"then F.t.seminfo=F.lookahead.seminfo;F.t.token=F.lookahead.token;F.lookahead.token="TK_EOS"else F.t.token=self:llex(F,F.t)end end;function c:lookahead(F)F.lookahead.token=self:llex(F,F.lookahead)end;function c:nextc(F)local M=a:zgetc(F.z)F.current=M;return M end;function c:save(F,M)local j=F.buff;F.buff=j..M end;function c:save_and_next(F)self:save(F,F.current)return self:nextc(F)end;function c:str2d(N)local O=tonumber(N)if O then return O end;if string.lower(string.sub(N,1,2))=="0x"then O=tonumber(N,16)if O then return O end end;return nil end;function c:buffreplace(F,P,Q)local O,j="",F.buff;for s=1,#j do local M=string.sub(j,s,s)if M==P then M=Q end;O=O..M end;F.buff=O end;function c:trydecpoint(F,R)local J=F.decpoint;self:buffreplace(F,J,F.decpoint)local S=self:str2d(F.buff)R.seminfo=S;if not S then self:buffreplace(F,F.decpoint,".")self:lexerror(F,"malformed number","TK_NUMBER")end end;function c:read_numeral(F,R)repeat self:save_and_next(F)until string.find(F.current,"%D")and F.current~="."if self:check_next(F,"Ee")then self:check_next(F,"+-")end;while string.find(F.current,"^%w$")or F.current=="_"do self:save_and_next(F)end;self:buffreplace(F,".",F.decpoint)local S=self:str2d(F.buff)R.seminfo=S;if not S then self:trydecpoint(F,R)end end;function c:skip_sep(F)local T=0;local N=F.current;self:save_and_next(F)while F.current=="="do self:save_and_next(F)T=T+1 end;return F.current==N and T or-T-1 end;function c:read_long_string(F,R,U)local V=0;self:save_and_next(F)if self:currIsNewline(F)then self:inclinenumber(F)end;while true do local M=F.current;if M=="EOZ"then self:lexerror(F,R and"unfinished long string"or"unfinished long comment","TK_EOS")elseif M=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(F)==U then self:save_and_next(F)V=V+1;if self.LUA_COMPAT_LSTR==1 then if U==0 then self:lexerror(F,"nesting of [[...]] is deprecated","[")end end end end elseif M=="]"then if self:skip_sep(F)==U then self:save_and_next(F)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then V=V-1;if U==0 and V>=0 then break end end;break end elseif self:currIsNewline(F)then self:save(F,"\n")self:inclinenumber(F)if not R then F.buff=""end else if R then self:save_and_next(F)else self:nextc(F)end end end;if R then local s=3+U;R.seminfo=string.sub(F.buff,s,-s)end end;function c:read_string(F,W,R)self:save_and_next(F)while F.current~=W do local M=F.current;if M=="EOZ"then self:lexerror(F,"unfinished string","TK_EOS")elseif self:currIsNewline(F)then self:lexerror(F,"unfinished string","TK_STRING")elseif M=="\\"then M=self:nextc(F)if self:currIsNewline(F)then self:save(F,"\n")self:inclinenumber(F)elseif M~="EOZ"then local X=string.find("abfnrtv",M,1,1)if X then self:save(F,string.sub("\a\b\f\n\r\t\v",X,X))self:nextc(F)elseif not string.find(M,"%d")then self:save_and_next(F)else M,X=0,0;repeat M=10*M+F.current;self:nextc(F)X=X+1 until X>=3 or not string.find(F.current,"%d")if M>255 then self:lexerror(F,"escape sequence too large","TK_STRING")end;self:save(F,string.char(M))end end else self:save_and_next(F)end end;self:save_and_next(F)R.seminfo=string.sub(F.buff,2,-2)end;function c:llex(F,R)F.buff=""while true do local M=F.current;if self:currIsNewline(F)then self:inclinenumber(F)elseif M=="-"then M=self:nextc(F)if M~="-"then return"-"end;local U=-1;if self:nextc(F)=='['then U=self:skip_sep(F)F.buff=""end;if U>=0 then self:read_long_string(F,nil,U)F.buff=""else while not self:currIsNewline(F)and F.current~="EOZ"do self:nextc(F)end end elseif M=="["then local U=self:skip_sep(F)if U>=0 then self:read_long_string(F,R,U)return"TK_STRING"elseif U==-1 then return"["else self:lexerror(F,"invalid long string delimiter","TK_STRING")end elseif M=="="then M=self:nextc(F)if M~="="then return"="else self:nextc(F)return"TK_EQ"end elseif M=="<"then M=self:nextc(F)if M~="="then return"<"else self:nextc(F)return"TK_LE"end elseif M==">"then M=self:nextc(F)if M~="="then return">"else self:nextc(F)return"TK_GE"end elseif M=="~"then M=self:nextc(F)if M~="="then return"~"else self:nextc(F)return"TK_NE"end elseif M=="\""or M=="'"then self:read_string(F,M,R)return"TK_STRING"elseif M=="."then M=self:save_and_next(F)if self:check_next(F,".")then if self:check_next(F,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(M,"%d")then return"."else self:read_numeral(F,R)return"TK_NUMBER"end elseif M=="EOZ"then return"TK_EOS"else if string.find(M,"%s")then self:nextc(F)elseif string.find(M,"%d")then self:read_numeral(F,R)return"TK_NUMBER"elseif string.find(M,"[_%a]")then repeat M=self:save_and_next(F)until M=="EOZ"or not string.find(M,"[_%w]")local Y=F.buff;local y=self.enums[Y]if y then return y end;R.seminfo=Y;return"TK_NAME"else self:nextc(F)return M end end end end;d.OpMode={iABC=0,iABx=1,iAsBx=2}d.SIZE_C=9;d.SIZE_B=9;d.SIZE_Bx=d.SIZE_C+d.SIZE_B;d.SIZE_A=8;d.SIZE_OP=6;d.POS_OP=0;d.POS_A=d.POS_OP+d.SIZE_OP;d.POS_C=d.POS_A+d.SIZE_A;d.POS_B=d.POS_C+d.SIZE_C;d.POS_Bx=d.POS_C;d.MAXARG_Bx=math.ldexp(1,d.SIZE_Bx)-1;d.MAXARG_sBx=math.floor(d.MAXARG_Bx/2)d.MAXARG_A=math.ldexp(1,d.SIZE_A)-1;d.MAXARG_B=math.ldexp(1,d.SIZE_B)-1;d.MAXARG_C=math.ldexp(1,d.SIZE_C)-1;function d:GET_OPCODE(X)return self.ROpCode[X.OP]end;function d:SET_OPCODE(X,Z)X.OP=self.OpCode[Z]end;function d:GETARG_A(X)return X.A end;function d:SETARG_A(X,_)X.A=_ end;function d:GETARG_B(X)return X.B end;function d:SETARG_B(X,k)X.B=k end;function d:GETARG_C(X)return X.C end;function d:SETARG_C(X,k)X.C=k end;function d:GETARG_Bx(X)return X.Bx end;function d:SETARG_Bx(X,k)X.Bx=k end;function d:GETARG_sBx(X)return X.Bx-self.MAXARG_sBx end;function d:SETARG_sBx(X,k)X.Bx=k+self.MAXARG_sBx end;function d:CREATE_ABC(Z,a0,k,M)return{OP=self.OpCode[Z],A=a0,B=k,C=M}end;function d:CREATE_ABx(Z,a0,a1)return{OP=self.OpCode[Z],A=a0,Bx=a1}end;function d:CREATE_Inst(M)local Z=M%64;M=(M-Z)/64;local a0=M%256;M=(M-a0)/256;return self:CREATE_ABx(Z,a0,M)end;function d:Instruction(X)if X.Bx then X.C=X.Bx%512;X.B=(X.Bx-X.C)/512 end;local a2=X.A*64+X.OP;local a3=a2%256;a2=X.C*64+(a2-a3)/256;local a4=a2%256;a2=X.B*128+(a2-a4)/256;local a5=a2%256;local a6=(a2-a5)/256;return string.char(a3,a4,a5,a6)end;function d:DecodeInst(x)local a7=string.byte;local X={}local a2=a7(x,1)local a8=a2%64;X.OP=a8;a2=a7(x,2)*4+(a2-a8)/64;local a0=a2%256;X.A=a0;a2=a7(x,3)*4+(a2-a0)/256;local M=a2%512;X.C=M;X.B=a7(x,4)*2+(a2-M)/512;local a9=self.OpMode[tonumber(string.sub(self.opmodes[a8+1],7,7))]if a9~="iABC"then X.Bx=X.B*512+X.C end;return X end;d.BITRK=math.ldexp(1,d.SIZE_B-1)function d:ISK(x)return x>=self.BITRK end;function d:INDEXK(aa)return x-self.BITRK end;d.MAXINDEXRK=d.BITRK-1;function d:RKASK(x)return x+self.BITRK end;d.NO_REG=d.MAXARG_A;d.opnames={}d.OpCode={}d.ROpCode={}local X=0;for v in string.gmatch("MOVE LOADK LOADBOOL LOADNIL GETUPVAL\nGETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE\nNEWTABLE SELF ADD SUB MUL\nDIV MOD POW UNM NOT\nLEN CONCAT JMP EQ LT\nLE TEST TESTSET CALL TAILCALL\nRETURN FORLOOP FORPREP TFORLOOP SETLIST\nCLOSE CLOSURE VARARG\n","%S+")do local r="OP_"..v;d.opnames[X]=v;d.OpCode[r]=X;d.ROpCode[X]=r;X=X+1 end;d.NUM_OPCODES=X;d.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function d:getOpMode(ab)return self.opmodes[self.OpCode[ab]]%4 end;function d:getBMode(ab)return math.floor(self.opmodes[self.OpCode[ab]]/16)%4 end;function d:getCMode(ab)return math.floor(self.opmodes[self.OpCode[ab]]/4)%4 end;function d:testAMode(ab)return math.floor(self.opmodes[self.OpCode[ab]]/64)%2 end;function d:testTMode(ab)return math.floor(self.opmodes[self.OpCode[ab]]/128)end;d.LFIELDS_PER_FLUSH=50;local function a9(ac,a0,k,M,ab)local d=d;return ac*128+a0*64+d.OpArgMask[k]*16+d.OpArgMask[M]*4+d.OpMode[ab]end;d.opmodes={a9(0,1,"OpArgK","OpArgN","iABx"),a9(0,1,"OpArgU","OpArgU","iABC"),a9(0,1,"OpArgR","OpArgN","iABC"),a9(0,1,"OpArgU","OpArgN","iABC"),a9(0,1,"OpArgK","OpArgN","iABx"),a9(0,1,"OpArgR","OpArgK","iABC"),a9(0,0,"OpArgK","OpArgN","iABx"),a9(0,0,"OpArgU","OpArgN","iABC"),a9(0,0,"OpArgK","OpArgK","iABC"),a9(0,1,"OpArgU","OpArgU","iABC"),a9(0,1,"OpArgR","OpArgK","iABC"),a9(0,1,"OpArgK","OpArgK","iABC"),a9(0,1,"OpArgK","OpArgK","iABC"),a9(0,1,"OpArgK","OpArgK","iABC"),a9(0,1,"OpArgK","OpArgK","iABC"),a9(0,1,"OpArgK","OpArgK","iABC"),a9(0,1,"OpArgK","OpArgK","iABC"),a9(0,1,"OpArgR","OpArgN","iABC"),a9(0,1,"OpArgR","OpArgN","iABC"),a9(0,1,"OpArgR","OpArgN","iABC"),a9(0,1,"OpArgR","OpArgR","iABC"),a9(0,0,"OpArgR","OpArgN","iAsBx"),a9(1,0,"OpArgK","OpArgK","iABC"),a9(1,0,"OpArgK","OpArgK","iABC"),a9(1,0,"OpArgK","OpArgK","iABC"),a9(1,1,"OpArgR","OpArgU","iABC"),a9(1,1,"OpArgR","OpArgU","iABC"),a9(0,1,"OpArgU","OpArgU","iABC"),a9(0,1,"OpArgU","OpArgU","iABC"),a9(0,0,"OpArgU","OpArgN","iABC"),a9(0,1,"OpArgR","OpArgN","iAsBx"),a9(0,1,"OpArgR","OpArgN","iAsBx"),a9(1,0,"OpArgN","OpArgU","iABC"),a9(0,0,"OpArgU","OpArgU","iABC"),a9(0,0,"OpArgN","OpArgN","iABC"),a9(0,1,"OpArgU","OpArgN","iABx"),a9(0,1,"OpArgU","OpArgN","iABC")}d.opmodes[0]=a9(0,1,"OpArgR","OpArgN","iABC")e.LUA_SIGNATURE="\27Lua"e.LUA_TNUMBER=3;e.LUA_TSTRING=4;e.LUA_TNIL=0;e.LUA_TBOOLEAN=1;e.LUA_TNONE=-1;e.LUAC_VERSION=0x51;e.LUAC_FORMAT=0;e.LUAC_HEADERSIZE=12;function e:make_setS()local j={}j.data=""local ad=function(N,j)if not N then return 0 end;j.data=j.data..N;return 0 end;return ad,j end;function e:make_setF(ae)local j={}j.h=io.open(ae,"wb")if not j.h then return nil end;local ad=function(N,j)if not j.h then return 0 end;if not N then if j.h:close()then return 0 end else if j.h:write(N)then return 0 end end;return 1 end;return ad,j end;function e:ttype(Z)local af=type(Z.value)if af=="number"then return self.LUA_TNUMBER elseif af=="string"then return self.LUA_TSTRING elseif af=="nil"then return self.LUA_TNIL elseif af=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function e:from_double(x)local function ag(v)local M=v%256;return(v-M)/256,string.char(M)end;local ah=0;if x<0 then ah=1;x=-x end;local ai,aj=math.frexp(x)if x==0 then ai,aj=0,0 elseif x==1/0 then ai,aj=0,2047 else ai=(ai*2-1)*math.ldexp(0.5,53)aj=aj+1022 end;local v,a7=""x=math.floor(ai)for X=1,6 do x,a7=ag(x)v=v..a7 end;x,a7=ag(aj*16+x)v=v..a7;x,a7=ag(ah*128+x)v=v..a7;return v end;function e:from_int(x)local v=""x=math.floor(x)if x<0 then x=4294967296+x end;for X=1,4 do local M=x%256;v=v..string.char(M)x=math.floor(x/256)end;return v end;function e:DumpBlock(k,ak)if ak.status==0 then ak.status=ak.write(k,ak.data)end end;function e:DumpChar(al,ak)self:DumpBlock(string.char(al),ak)end;function e:DumpInt(x,ak)self:DumpBlock(self:from_int(x),ak)end;function e:DumpSizeT(x,ak)self:DumpBlock(self:from_int(x),ak)if g==8 then self:DumpBlock(self:from_int(0),ak)end end;function e:DumpNumber(x,ak)self:DumpBlock(self:from_double(x),ak)end;function e:DumpString(N,ak)if N==nil then self:DumpSizeT(0,ak)else N=N.."\0"self:DumpSizeT(#N,ak)self:DumpBlock(N,ak)end end;function e:DumpCode(am,ak)local r=am.sizecode;self:DumpInt(r,ak)for X=0,r-1 do self:DumpBlock(d:Instruction(am.code[X]),ak)end end;function e:DumpConstants(am,ak)local r=am.sizek;self:DumpInt(r,ak)for X=0,r-1 do local Z=am.k[X]local af=self:ttype(Z)self:DumpChar(af,ak)if af==self.LUA_TNIL then elseif af==self.LUA_TBOOLEAN then self:DumpChar(Z.value and 1 or 0,ak)elseif af==self.LUA_TNUMBER then self:DumpNumber(Z.value,ak)elseif af==self.LUA_TSTRING then self:DumpString(Z.value,ak)else end end;r=am.sizep;self:DumpInt(r,ak)for X=0,r-1 do self:DumpFunction(am.p[X],am.source,ak)end end;function e:DumpDebug(am,ak)local r;r=ak.strip and 0 or am.sizelineinfo;self:DumpInt(r,ak)for X=0,r-1 do self:DumpInt(am.lineinfo[X],ak)end;r=ak.strip and 0 or am.sizelocvars;self:DumpInt(r,ak)for X=0,r-1 do self:DumpString(am.locvars[X].varname,ak)self:DumpInt(am.locvars[X].startpc,ak)self:DumpInt(am.locvars[X].endpc,ak)end;r=ak.strip and 0 or am.sizeupvalues;self:DumpInt(r,ak)for X=0,r-1 do self:DumpString(am.upvalues[X],ak)end end;function e:DumpFunction(am,s,ak)local m=am.source;if m==s or ak.strip then m=nil end;self:DumpString(m,ak)self:DumpInt(am.lineDefined,ak)self:DumpInt(am.lastlinedefined,ak)self:DumpChar(am.nups,ak)self:DumpChar(am.numparams,ak)self:DumpChar(am.is_vararg,ak)self:DumpChar(am.maxstacksize,ak)self:DumpCode(am,ak)self:DumpConstants(am,ak)self:DumpDebug(am,ak)end;function e:DumpHeader(ak)local an=self:header()assert(#an==self.LUAC_HEADERSIZE)self:DumpBlock(an,ak)end;function e:header()local x=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,x,4,g,4,8,0)end;function e:dump(K,am,ao,l,ap)local ak={}ak.L=K;ak.write=ao;ak.data=l;ak.strip=ap;ak.status=0;self:DumpHeader(ak)self:DumpFunction(am,nil,ak)ak.write(nil,ak.data)return ak.status end;f.MAXSTACK=250;function f:ttisnumber(Z)if Z then return type(Z.value)=="number"else return false end end;function f:nvalue(Z)return Z.value end;function f:setnilvalue(Z)Z.value=nil end;function f:setsvalue(Z,x)Z.value=x end;f.setnvalue=f.setsvalue;f.sethvalue=f.setsvalue;f.setbvalue=f.setsvalue;function f:numadd(a0,k)return a0+k end;function f:numsub(a0,k)return a0-k end;function f:nummul(a0,k)return a0*k end;function f:numdiv(a0,k)return a0/k end;function f:nummod(a0,k)return a0%k end;function f:numpow(a0,k)return a0^k end;function f:numunm(a0)return-a0 end;function f:numisnan(a0)return not a0==a0 end;f.NO_JUMP=-1;f.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}f.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function f:getcode(aq,ar)return aq.f.code[ar.info]end;function f:codeAsBx(aq,Z,as,at)return self:codeABx(aq,Z,as,at+d.MAXARG_sBx)end;function f:setmultret(aq,ar)self:setreturns(aq,ar,b.LUA_MULTRET)end;function f:hasjumps(ar)return ar.t~=ar.f end;function f:isnumeral(ar)return ar.k=="VKNUM"and ar.t==self.NO_JUMP and ar.f==self.NO_JUMP end;function f:_nil(aq,P,r)if aq.pc>aq.lasttarget then if aq.pc==0 then if P>=aq.nactvar then return end else local au=aq.f.code[aq.pc-1]if d:GET_OPCODE(au)=="OP_LOADNIL"then local av=d:GETARG_A(au)local aw=d:GETARG_B(au)if av<=P and P<=aw+1 then if P+r-1>aw then d:SETARG_B(au,P+r-1)end;return end end end end;self:codeABC(aq,"OP_LOADNIL",P,P+r-1,0)end;function f:jump(aq)local ax=aq.jpc;aq.jpc=self.NO_JUMP;local ay=self:codeAsBx(aq,"OP_JMP",0,self.NO_JUMP)ay=self:concat(aq,ay,ax)return ay end;function f:ret(aq,C,az)self:codeABC(aq,"OP_RETURN",C,az+1,0)end;function f:condjump(aq,a8,as,aA,aB)self:codeABC(aq,a8,as,aA,aB)return self:jump(aq)end;function f:fixjump(aq,aC,aD)local aE=aq.f.code[aC]local aF=aD-(aC+1)h(aD~=self.NO_JUMP)if math.abs(aF)>d.MAXARG_sBx then c:syntaxerror(aq.ls,"control structure too long")end;d:SETARG_sBx(aE,aF)end;function f:getlabel(aq)aq.lasttarget=aq.pc;return aq.pc end;function f:getjump(aq,aC)local aF=d:GETARG_sBx(aq.f.code[aC])if aF==self.NO_JUMP then return self.NO_JUMP else return aC+1+aF end end;function f:getjumpcontrol(aq,aC)local aG=aq.f.code[aC]local aH=aq.f.code[aC-1]if aC>=1 and d:testTMode(d:GET_OPCODE(aH))~=0 then return aH else return aG end end;function f:need_value(aq,aI)while aI~=self.NO_JUMP do local X=self:getjumpcontrol(aq,aI)if d:GET_OPCODE(X)~="OP_TESTSET"then return true end;aI=self:getjump(aq,aI)end;return false end;function f:patchtestreg(aq,aJ,aK)local X=self:getjumpcontrol(aq,aJ)if d:GET_OPCODE(X)~="OP_TESTSET"then return false end;if aK~=d.NO_REG and aK~=d:GETARG_B(X)then d:SETARG_A(X,aK)else d:SET_OPCODE(X,"OP_TEST")local k=d:GETARG_B(X)d:SETARG_A(X,k)d:SETARG_B(X,0)end;return true end;function f:removevalues(aq,aI)while aI~=self.NO_JUMP do self:patchtestreg(aq,aI,d.NO_REG)aI=self:getjump(aq,aI)end end;function f:patchlistaux(aq,aI,aL,aK,aM)while aI~=self.NO_JUMP do local aN=self:getjump(aq,aI)if self:patchtestreg(aq,aI,aK)then self:fixjump(aq,aI,aL)else self:fixjump(aq,aI,aM)end;aI=aN end end;function f:dischargejpc(aq)self:patchlistaux(aq,aq.jpc,aq.pc,d.NO_REG,aq.pc)aq.jpc=self.NO_JUMP end;function f:patchlist(aq,aI,aO)if aO==aq.pc then self:patchtohere(aq,aI)else h(aO<aq.pc)self:patchlistaux(aq,aI,aO,d.NO_REG,aO)end end;function f:patchtohere(aq,aI)self:getlabel(aq)aq.jpc=self:concat(aq,aq.jpc,aI)end;function f:concat(aq,aP,aQ)if aQ==self.NO_JUMP then return aP elseif aP==self.NO_JUMP then return aQ else local aI=aP;local aN=self:getjump(aq,aI)while aN~=self.NO_JUMP do aI=aN;aN=self:getjump(aq,aI)end;self:fixjump(aq,aI,aQ)end;return aP end;function f:checkstack(aq,r)local aR=aq.freereg+r;if aR>aq.f.maxstacksize then if aR>=self.MAXSTACK then c:syntaxerror(aq.ls,"function or expression too complex")end;aq.f.maxstacksize=aR end end;function f:reserveregs(aq,r)self:checkstack(aq,r)aq.freereg=aq.freereg+r end;function f:freereg(aq,aK)if not d:ISK(aK)and aK>=aq.nactvar then aq.freereg=aq.freereg-1;h(aK==aq.freereg)end end;function f:freeexp(aq,ar)if ar.k=="VNONRELOC"then self:freereg(aq,ar.info)end end;function f:addk(aq,aS,v)local K=aq.L;local aT=aq.h[aS.value]local am=aq.f;if self:ttisnumber(aT)then return self:nvalue(aT)else aT={}self:setnvalue(aT,aq.nk)aq.h[aS.value]=aT;b:growvector(K,am.k,aq.nk,am.sizek,nil,d.MAXARG_Bx,"constant table overflow")am.k[aq.nk]=v;local aU=aq.nk;aq.nk=aq.nk+1;return aU end end;function f:stringK(aq,N)local Z={}self:setsvalue(Z,N)return self:addk(aq,Z,Z)end;function f:numberK(aq,aa)local Z={}self:setnvalue(Z,aa)return self:addk(aq,Z,Z)end;function f:boolK(aq,k)local Z={}self:setbvalue(Z,k)return self:addk(aq,Z,Z)end;function f:nilK(aq)local aS,v={},{}self:setnilvalue(v)self:sethvalue(aS,aq.h)return self:addk(aq,aS,v)end;function f:setreturns(aq,ar,aV)if ar.k=="VCALL"then d:SETARG_C(self:getcode(aq,ar),aV+1)elseif ar.k=="VVARARG"then d:SETARG_B(self:getcode(aq,ar),aV+1)d:SETARG_A(self:getcode(aq,ar),aq.freereg)f:reserveregs(aq,1)end end;function f:setoneret(aq,ar)if ar.k=="VCALL"then ar.k="VNONRELOC"ar.info=d:GETARG_A(self:getcode(aq,ar))elseif ar.k=="VVARARG"then d:SETARG_B(self:getcode(aq,ar),2)ar.k="VRELOCABLE"end end;function f:dischargevars(aq,ar)local aS=ar.k;if aS=="VLOCAL"then ar.k="VNONRELOC"elseif aS=="VUPVAL"then ar.info=self:codeABC(aq,"OP_GETUPVAL",0,ar.info,0)ar.k="VRELOCABLE"elseif aS=="VGLOBAL"then ar.info=self:codeABx(aq,"OP_GETGLOBAL",0,ar.info)ar.k="VRELOCABLE"elseif aS=="VINDEXED"then self:freereg(aq,ar.aux)self:freereg(aq,ar.info)ar.info=self:codeABC(aq,"OP_GETTABLE",0,ar.info,ar.aux)ar.k="VRELOCABLE"elseif aS=="VVARARG"or aS=="VCALL"then self:setoneret(aq,ar)else end end;function f:code_label(aq,as,k,aW)self:getlabel(aq)return self:codeABC(aq,"OP_LOADBOOL",as,k,aW)end;function f:discharge2reg(aq,ar,aK)self:dischargevars(aq,ar)local aS=ar.k;if aS=="VNIL"then self:_nil(aq,aK,1)elseif aS=="VFALSE"or aS=="VTRUE"then self:codeABC(aq,"OP_LOADBOOL",aK,ar.k=="VTRUE"and 1 or 0,0)elseif aS=="VK"then self:codeABx(aq,"OP_LOADK",aK,ar.info)elseif aS=="VKNUM"then self:codeABx(aq,"OP_LOADK",aK,self:numberK(aq,ar.nval))elseif aS=="VRELOCABLE"then local aC=self:getcode(aq,ar)d:SETARG_A(aC,aK)elseif aS=="VNONRELOC"then if aK~=ar.info then self:codeABC(aq,"OP_MOVE",aK,ar.info,0)end else h(ar.k=="VVOID"or ar.k=="VJMP")return end;ar.info=aK;ar.k="VNONRELOC"end;function f:discharge2anyreg(aq,ar)if ar.k~="VNONRELOC"then self:reserveregs(aq,1)self:discharge2reg(aq,ar,aq.freereg-1)end end;function f:exp2reg(aq,ar,aK)self:discharge2reg(aq,ar,aK)if ar.k=="VJMP"then ar.t=self:concat(aq,ar.t,ar.info)end;if self:hasjumps(ar)then local aX;local aY=self.NO_JUMP;local aZ=self.NO_JUMP;if self:need_value(aq,ar.t)or self:need_value(aq,ar.f)then local a_=ar.k=="VJMP"and self.NO_JUMP or self:jump(aq)aY=self:code_label(aq,aK,0,1)aZ=self:code_label(aq,aK,1,0)self:patchtohere(aq,a_)end;aX=self:getlabel(aq)self:patchlistaux(aq,ar.f,aX,aK,aY)self:patchlistaux(aq,ar.t,aX,aK,aZ)end;ar.f,ar.t=self.NO_JUMP,self.NO_JUMP;ar.info=aK;ar.k="VNONRELOC"end;function f:exp2nextreg(aq,ar)self:dischargevars(aq,ar)self:freeexp(aq,ar)self:reserveregs(aq,1)self:exp2reg(aq,ar,aq.freereg-1)end;function f:exp2anyreg(aq,ar)self:dischargevars(aq,ar)if ar.k=="VNONRELOC"then if not self:hasjumps(ar)then return ar.info end;if ar.info>=aq.nactvar then self:exp2reg(aq,ar,ar.info)return ar.info end end;self:exp2nextreg(aq,ar)return ar.info end;function f:exp2val(aq,ar)if self:hasjumps(ar)then self:exp2anyreg(aq,ar)else self:dischargevars(aq,ar)end end;function f:exp2RK(aq,ar)self:exp2val(aq,ar)local aS=ar.k;if aS=="VKNUM"or aS=="VTRUE"or aS=="VFALSE"or aS=="VNIL"then if aq.nk<=d.MAXINDEXRK then if ar.k=="VNIL"then ar.info=self:nilK(aq)else ar.info=ar.k=="VKNUM"and self:numberK(aq,ar.nval)or self:boolK(aq,ar.k=="VTRUE")end;ar.k="VK"return d:RKASK(ar.info)end elseif aS=="VK"then if ar.info<=d.MAXINDEXRK then return d:RKASK(ar.info)end else end;return self:exp2anyreg(aq,ar)end;function f:storevar(aq,b0,b1)local aS=b0.k;if aS=="VLOCAL"then self:freeexp(aq,b1)self:exp2reg(aq,b1,b0.info)return elseif aS=="VUPVAL"then local ar=self:exp2anyreg(aq,b1)self:codeABC(aq,"OP_SETUPVAL",ar,b0.info,0)elseif aS=="VGLOBAL"then local ar=self:exp2anyreg(aq,b1)self:codeABx(aq,"OP_SETGLOBAL",ar,b0.info)elseif aS=="VINDEXED"then local ar=self:exp2RK(aq,b1)self:codeABC(aq,"OP_SETTABLE",b0.info,b0.aux,ar)else h(0)end;self:freeexp(aq,b1)end;function f:_self(aq,ar,b2)self:exp2anyreg(aq,ar)self:freeexp(aq,ar)local b3=aq.freereg;self:reserveregs(aq,2)self:codeABC(aq,"OP_SELF",b3,ar.info,self:exp2RK(aq,b2))self:freeexp(aq,b2)ar.info=b3;ar.k="VNONRELOC"end;function f:invertjump(aq,ar)local aC=self:getjumpcontrol(aq,ar.info)h(d:testTMode(d:GET_OPCODE(aC))~=0 and d:GET_OPCODE(aC)~="OP_TESTSET"and d:GET_OPCODE(aC)~="OP_TEST")d:SETARG_A(aC,d:GETARG_A(aC)==0 and 1 or 0)end;function f:jumponcond(aq,ar,b4)if ar.k=="VRELOCABLE"then local b5=self:getcode(aq,ar)if d:GET_OPCODE(b5)=="OP_NOT"then aq.pc=aq.pc-1;return self:condjump(aq,"OP_TEST",d:GETARG_B(b5),0,b4 and 0 or 1)end end;self:discharge2anyreg(aq,ar)self:freeexp(aq,ar)return self:condjump(aq,"OP_TESTSET",d.NO_REG,ar.info,b4 and 1 or 0)end;function f:goiftrue(aq,ar)local aC;self:dischargevars(aq,ar)local aS=ar.k;if aS=="VK"or aS=="VKNUM"or aS=="VTRUE"then aC=self.NO_JUMP elseif aS=="VFALSE"then aC=self:jump(aq)elseif aS=="VJMP"then self:invertjump(aq,ar)aC=ar.info else aC=self:jumponcond(aq,ar,false)end;ar.f=self:concat(aq,ar.f,aC)self:patchtohere(aq,ar.t)ar.t=self.NO_JUMP end;function f:goiffalse(aq,ar)local aC;self:dischargevars(aq,ar)local aS=ar.k;if aS=="VNIL"or aS=="VFALSE"then aC=self.NO_JUMP elseif aS=="VTRUE"then aC=self:jump(aq)elseif aS=="VJMP"then aC=ar.info else aC=self:jumponcond(aq,ar,true)end;ar.t=self:concat(aq,ar.t,aC)self:patchtohere(aq,ar.f)ar.f=self.NO_JUMP end;function f:codenot(aq,ar)self:dischargevars(aq,ar)local aS=ar.k;if aS=="VNIL"or aS=="VFALSE"then ar.k="VTRUE"elseif aS=="VK"or aS=="VKNUM"or aS=="VTRUE"then ar.k="VFALSE"elseif aS=="VJMP"then self:invertjump(aq,ar)elseif aS=="VRELOCABLE"or aS=="VNONRELOC"then self:discharge2anyreg(aq,ar)self:freeexp(aq,ar)ar.info=self:codeABC(aq,"OP_NOT",0,ar.info,0)ar.k="VRELOCABLE"else h(0)end;ar.f,ar.t=ar.t,ar.f;self:removevalues(aq,ar.f)self:removevalues(aq,ar.t)end;function f:indexed(aq,ac,aS)ac.aux=self:exp2RK(aq,aS)ac.k="VINDEXED"end;function f:constfolding(a8,b6,b7)local aa;if not self:isnumeral(b6)or not self:isnumeral(b7)then return false end;local b8=b6.nval;local b9=b7.nval;if a8=="OP_ADD"then aa=self:numadd(b8,b9)elseif a8=="OP_SUB"then aa=self:numsub(b8,b9)elseif a8=="OP_MUL"then aa=self:nummul(b8,b9)elseif a8=="OP_DIV"then if b9==0 then return false end;aa=self:numdiv(b8,b9)elseif a8=="OP_MOD"then if b9==0 then return false end;aa=self:nummod(b8,b9)elseif a8=="OP_POW"then aa=self:numpow(b8,b9)elseif a8=="OP_UNM"then aa=self:numunm(b8)elseif a8=="OP_LEN"then return false else h(0)aa=0 end;if self:numisnan(aa)then return false end;b6.nval=aa;return true end;function f:codearith(aq,a8,b6,b7)if self:constfolding(a8,b6,b7)then return else local ba=a8~="OP_UNM"and a8~="OP_LEN"and self:exp2RK(aq,b7)or 0;local bb=self:exp2RK(aq,b6)if bb>ba then self:freeexp(aq,b6)self:freeexp(aq,b7)else self:freeexp(aq,b7)self:freeexp(aq,b6)end;b6.info=self:codeABC(aq,a8,0,bb,ba)b6.k="VRELOCABLE"end end;function f:codecomp(aq,a8,b4,b6,b7)local bb=self:exp2RK(aq,b6)local ba=self:exp2RK(aq,b7)self:freeexp(aq,b7)self:freeexp(aq,b6)if b4==0 and a8~="OP_EQ"then bb,ba=ba,bb;b4=1 end;b6.info=self:condjump(aq,a8,b4,bb,ba)b6.k="VJMP"end;function f:prefix(aq,a8,ar)local b7={}b7.t,b7.f=self.NO_JUMP,self.NO_JUMP;b7.k="VKNUM"b7.nval=0;if a8=="OPR_MINUS"then if not self:isnumeral(ar)then self:exp2anyreg(aq,ar)end;self:codearith(aq,"OP_UNM",ar,b7)elseif a8=="OPR_NOT"then self:codenot(aq,ar)elseif a8=="OPR_LEN"then self:exp2anyreg(aq,ar)self:codearith(aq,"OP_LEN",ar,b7)else h(0)end end;function f:infix(aq,a8,v)if a8=="OPR_AND"then self:goiftrue(aq,v)elseif a8=="OPR_OR"then self:goiffalse(aq,v)elseif a8=="OPR_CONCAT"then self:exp2nextreg(aq,v)elseif a8=="OPR_ADD"or a8=="OPR_SUB"or a8=="OPR_MUL"or a8=="OPR_DIV"or a8=="OPR_MOD"or a8=="OPR_POW"then if not self:isnumeral(v)then self:exp2RK(aq,v)end else self:exp2RK(aq,v)end end;f.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}f.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}f.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function f:posfix(aq,a8,b6,b7)local function bc(b6,b7)b6.k=b7.k;b6.info=b7.info;b6.aux=b7.aux;b6.nval=b7.nval;b6.t=b7.t;b6.f=b7.f end;if a8=="OPR_AND"then h(b6.t==self.NO_JUMP)self:dischargevars(aq,b7)b7.f=self:concat(aq,b7.f,b6.f)bc(b6,b7)elseif a8=="OPR_OR"then h(b6.f==self.NO_JUMP)self:dischargevars(aq,b7)b7.t=self:concat(aq,b7.t,b6.t)bc(b6,b7)elseif a8=="OPR_CONCAT"then self:exp2val(aq,b7)if b7.k=="VRELOCABLE"and d:GET_OPCODE(self:getcode(aq,b7))=="OP_CONCAT"then h(b6.info==d:GETARG_B(self:getcode(aq,b7))-1)self:freeexp(aq,b6)d:SETARG_B(self:getcode(aq,b7),b6.info)b6.k="VRELOCABLE"b6.info=b7.info else self:exp2nextreg(aq,b7)self:codearith(aq,"OP_CONCAT",b6,b7)end else local bd=self.arith_op[a8]if bd then self:codearith(aq,bd,b6,b7)else local be=self.comp_op[a8]if be then self:codecomp(aq,be,self.comp_cond[a8],b6,b7)else h(0)end end end end;function f:fixline(aq,bf)aq.f.lineinfo[aq.pc-1]=bf end;function f:code(aq,X,bf)local am=aq.f;self:dischargejpc(aq)b:growvector(aq.L,am.code,aq.pc,am.sizecode,nil,b.MAX_INT,"code size overflow")am.code[aq.pc]=X;b:growvector(aq.L,am.lineinfo,aq.pc,am.sizelineinfo,nil,b.MAX_INT,"code size overflow")am.lineinfo[aq.pc]=bf;local aC=aq.pc;aq.pc=aq.pc+1;return aC end;function f:codeABC(aq,Z,a0,k,M)h(d:getOpMode(Z)==d.OpMode.iABC)h(d:getBMode(Z)~=d.OpArgMask.OpArgN or k==0)h(d:getCMode(Z)~=d.OpArgMask.OpArgN or M==0)return self:code(aq,d:CREATE_ABC(Z,a0,k,M),aq.ls.lastline)end;function f:codeABx(aq,Z,a0,a1)h(d:getOpMode(Z)==d.OpMode.iABx or d:getOpMode(Z)==d.OpMode.iAsBx)h(d:getCMode(Z)==d.OpArgMask.OpArgN)return self:code(aq,d:CREATE_ABx(Z,a0,a1),aq.ls.lastline)end;function f:setlist(aq,bg,bh,bi)local M=math.floor((bh-1)/d.LFIELDS_PER_FLUSH)+1;local k=bi==b.LUA_MULTRET and 0 or bi;h(bi~=0)if M<=d.MAXARG_C then self:codeABC(aq,"OP_SETLIST",bg,k,M)else self:codeABC(aq,"OP_SETLIST",bg,k,0)self:code(aq,d:CREATE_Inst(M),aq.ls.lastline)end;aq.freereg=bg+1 end;b.LUA_QS=c.LUA_QS or"'%s'"b.SHRT_MAX=32767;b.LUAI_MAXVARS=200;b.LUAI_MAXUPVALUES=60;b.MAX_INT=c.MAX_INT or 2147483645;b.LUAI_MAXCCALLS=200;b.VARARG_HASARG=1;b.HASARG_MASK=2;b.VARARG_ISVARARG=2;b.VARARG_NEEDSARG=4;b.LUA_MULTRET=-1;function b:LUA_QL(x)return"'"..x.."'"end;function b:growvector(K,v,bh,bj,ac,bk,ar)if bh>=bk then error(ar)end end;function b:newproto(K)local am={}am.k={}am.sizek=0;am.p={}am.sizep=0;am.code={}am.sizecode=0;am.sizelineinfo=0;am.sizeupvalues=0;am.nups=0;am.upvalues={}am.numparams=0;am.is_vararg=0;am.maxstacksize=0;am.lineinfo={}am.sizelocvars=0;am.locvars={}am.lineDefined=0;am.lastlinedefined=0;am.source=nil;return am end;function b:int2fb(x)local ar=0;while x>=16 do x=math.floor((x+1)/2)ar=ar+1 end;if x<8 then return x else return(ar+1)*8+x-8 end end;function b:hasmultret(aS)return aS=="VCALL"or aS=="VVARARG"end;function b:getlocvar(aq,X)return aq.f.locvars[aq.actvar[X]]end;function b:checklimit(aq,v,D,ab)if v>D then self:errorlimit(aq,D,ab)end end;function b:anchor_token(F)if F.t.token=="TK_NAME"or F.t.token=="TK_STRING"then end end;function b:error_expected(F,G)c:syntaxerror(F,string.format(self.LUA_QS.." expected",c:token2str(F,G)))end;function b:errorlimit(aq,bk,bl)local H=aq.f.linedefined==0 and string.format("main function has more than %d %s",bk,bl)or string.format("function at line %d has more than %d %s",aq.f.linedefined,bk,bl)c:lexerror(aq.ls,H,0)end;function b:testnext(F,M)if F.t.token==M then c:next(F)return true else return false end end;function b:check(F,M)if F.t.token~=M then self:error_expected(F,M)end end;function b:checknext(F,M)self:check(F,M)c:next(F)end;function b:check_condition(F,M,H)if not M then c:syntaxerror(F,H)end end;function b:check_match(F,bl,bm,bn)if not self:testnext(F,bl)then if bn==F.linenumber then self:error_expected(F,bl)else c:syntaxerror(F,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",c:token2str(F,bl),c:token2str(F,bm),bn))end end end;function b:str_checkname(F)self:check(F,"TK_NAME")local Y=F.t.seminfo;c:next(F)return Y end;function b:init_exp(ar,aS,X)ar.f,ar.t=f.NO_JUMP,f.NO_JUMP;ar.k=aS;ar.info=X end;function b:codestring(F,ar,N)self:init_exp(ar,"VK",f:stringK(F.fs,N))end;function b:checkname(F,ar)self:codestring(F,ar,self:str_checkname(F))end;function b:registerlocalvar(F,bo)local aq=F.fs;local am=aq.f;self:growvector(F.L,am.locvars,aq.nlocvars,am.sizelocvars,nil,self.SHRT_MAX,"too many local variables")am.locvars[aq.nlocvars]={}am.locvars[aq.nlocvars].varname=bo;local bp=aq.nlocvars;aq.nlocvars=aq.nlocvars+1;return bp end;function b:new_localvarliteral(F,v,r)self:new_localvar(F,v,r)end;function b:new_localvar(F,name,r)local aq=F.fs;self:checklimit(aq,aq.nactvar+r+1,self.LUAI_MAXVARS,"local variables")aq.actvar[aq.nactvar+r]=self:registerlocalvar(F,name)end;function b:adjustlocalvars(F,bq)local aq=F.fs;aq.nactvar=aq.nactvar+bq;for X=bq,1,-1 do self:getlocvar(aq,aq.nactvar-X).startpc=aq.pc end end;function b:removevars(F,br)local aq=F.fs;while aq.nactvar>br do aq.nactvar=aq.nactvar-1;self:getlocvar(aq,aq.nactvar).endpc=aq.pc end end;function b:indexupvalue(aq,name,v)local am=aq.f;for X=0,am.nups-1 do if aq.upvalues[X].k==v.k and aq.upvalues[X].info==v.info then h(am.upvalues[X]==name)return X end end;self:checklimit(aq,am.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(aq.L,am.upvalues,am.nups,am.sizeupvalues,nil,self.MAX_INT,"")am.upvalues[am.nups]=name;h(v.k=="VLOCAL"or v.k=="VUPVAL")aq.upvalues[am.nups]={k=v.k,info=v.info}local bs=am.nups;am.nups=am.nups+1;return bs end;function b:searchvar(aq,r)for X=aq.nactvar-1,0,-1 do if r==self:getlocvar(aq,X).varname then return X end end;return-1 end;function b:markupval(aq,bt)local bu=aq.bl;while bu and bu.nactvar>bt do bu=bu.previous end;if bu then bu.upval=true end end;function b:singlevaraux(aq,r,b0,bg)if aq==nil then self:init_exp(b0,"VGLOBAL",d.NO_REG)return"VGLOBAL"else local v=self:searchvar(aq,r)if v>=0 then self:init_exp(b0,"VLOCAL",v)if bg==0 then self:markupval(aq,v)end;return"VLOCAL"else if self:singlevaraux(aq.prev,r,b0,0)=="VGLOBAL"then return"VGLOBAL"end;b0.info=self:indexupvalue(aq,r,b0)b0.k="VUPVAL"return"VUPVAL"end end end;function b:singlevar(F,b0)local bo=self:str_checkname(F)local aq=F.fs;if self:singlevaraux(aq,bo,b0,1)=="VGLOBAL"then b0.info=f:stringK(aq,bo)end end;function b:adjust_assign(F,bq,bv,ar)local aq=F.fs;local bw=bq-bv;if self:hasmultret(ar.k)then bw=bw+1;if bw<=0 then bw=0 end;f:setreturns(aq,ar,bw)if bw>1 then f:reserveregs(aq,bw-1)end else if ar.k~="VVOID"then f:exp2nextreg(aq,ar)end;if bw>0 then local aK=aq.freereg;f:reserveregs(aq,bw)f:_nil(aq,aK,bw)end end end;function b:enterlevel(F)F.L.nCcalls=F.L.nCcalls+1;if F.L.nCcalls>self.LUAI_MAXCCALLS then c:lexerror(F,"chunk has too many syntax levels",0)end end;function b:leavelevel(F)F.L.nCcalls=F.L.nCcalls-1 end;function b:enterblock(aq,bu,bx)bu.breaklist=f.NO_JUMP;bu.isbreakable=bx;bu.nactvar=aq.nactvar;bu.upval=false;bu.previous=aq.bl;aq.bl=bu;h(aq.freereg==aq.nactvar)end;function b:leaveblock(aq)local bu=aq.bl;aq.bl=bu.previous;self:removevars(aq.ls,bu.nactvar)if bu.upval then f:codeABC(aq,"OP_CLOSE",bu.nactvar,0,0)end;h(not bu.isbreakable or not bu.upval)h(bu.nactvar==aq.nactvar)aq.freereg=aq.nactvar;f:patchtohere(aq,bu.breaklist)end;function b:pushclosure(F,b3,v)local aq=F.fs;local am=aq.f;self:growvector(F.L,am.p,aq.np,am.sizep,nil,d.MAXARG_Bx,"constant table overflow")am.p[aq.np]=b3.f;aq.np=aq.np+1;self:init_exp(v,"VRELOCABLE",f:codeABx(aq,"OP_CLOSURE",0,aq.np-1))for X=0,b3.f.nups-1 do local Z=b3.upvalues[X].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"f:codeABC(aq,Z,0,b3.upvalues[X].info,0)end end;function b:open_func(F,aq)local K=F.L;local am=self:newproto(F.L)aq.f=am;aq.prev=F.fs;aq.ls=F;aq.L=K;F.fs=aq;aq.pc=0;aq.lasttarget=-1;aq.jpc=f.NO_JUMP;aq.freereg=0;aq.nk=0;aq.np=0;aq.nlocvars=0;aq.nactvar=0;aq.bl=nil;am.source=F.source;am.maxstacksize=2;aq.h={}end;function b:close_func(F)local K=F.L;local aq=F.fs;local am=aq.f;self:removevars(F,0)f:ret(aq,0,0)am.sizecode=aq.pc;am.sizelineinfo=aq.pc;am.sizek=aq.nk;am.sizep=aq.np;am.sizelocvars=aq.nlocvars;am.sizeupvalues=am.nups;h(aq.bl==nil)F.fs=aq.prev;if aq then self:anchor_token(F)end end;function b:parser(K,q,j,name)local by={}by.t={}by.lookahead={}local bz={}bz.upvalues={}bz.actvar={}K.nCcalls=0;by.buff=j;c:setinput(K,by,q,name)self:open_func(by,bz)bz.f.is_vararg=self.VARARG_ISVARARG;c:next(by)self:chunk(by)self:check(by,"TK_EOS")self:close_func(by)h(bz.prev==nil)h(bz.f.nups==0)h(by.fs==nil)return bz.f end;function b:field(F,v)local aq=F.fs;local b2={}f:exp2anyreg(aq,v)c:next(F)self:checkname(F,b2)f:indexed(aq,v,b2)end;function b:yindex(F,v)c:next(F)self:expr(F,v)f:exp2val(F.fs,v)self:checknext(F,"]")end;function b:recfield(F,bA)local aq=F.fs;local aK=F.fs.freereg;local b2,bB={},{}if F.t.token=="TK_NAME"then self:checklimit(aq,bA.nh,self.MAX_INT,"items in a constructor")self:checkname(F,b2)else self:yindex(F,b2)end;bA.nh=bA.nh+1;self:checknext(F,"=")local bC=f:exp2RK(aq,b2)self:expr(F,bB)f:codeABC(aq,"OP_SETTABLE",bA.t.info,bC,f:exp2RK(aq,bB))aq.freereg=aK end;function b:closelistfield(aq,bA)if bA.v.k=="VVOID"then return end;f:exp2nextreg(aq,bA.v)bA.v.k="VVOID"if bA.tostore==d.LFIELDS_PER_FLUSH then f:setlist(aq,bA.t.info,bA.na,bA.tostore)bA.tostore=0 end end;function b:lastlistfield(aq,bA)if bA.tostore==0 then return end;if self:hasmultret(bA.v.k)then f:setmultret(aq,bA.v)f:setlist(aq,bA.t.info,bA.na,self.LUA_MULTRET)bA.na=bA.na-1 else if bA.v.k~="VVOID"then f:exp2nextreg(aq,bA.v)end;f:setlist(aq,bA.t.info,bA.na,bA.tostore)end end;function b:listfield(F,bA)self:expr(F,bA.v)self:checklimit(F.fs,bA.na,self.MAX_INT,"items in a constructor")bA.na=bA.na+1;bA.tostore=bA.tostore+1 end;function b:constructor(F,ac)local aq=F.fs;local bf=F.linenumber;local aC=f:codeABC(aq,"OP_NEWTABLE",0,0,0)local bA={}bA.v={}bA.na,bA.nh,bA.tostore=0,0,0;bA.t=ac;self:init_exp(ac,"VRELOCABLE",aC)self:init_exp(bA.v,"VVOID",0)f:exp2nextreg(F.fs,ac)self:checknext(F,"{")repeat h(bA.v.k=="VVOID"or bA.tostore>0)if F.t.token=="}"then break end;self:closelistfield(aq,bA)local M=F.t.token;if M=="TK_NAME"then c:lookahead(F)if F.lookahead.token~="="then self:listfield(F,bA)else self:recfield(F,bA)end elseif M=="["then self:recfield(F,bA)else self:listfield(F,bA)end until not self:testnext(F,",")and not self:testnext(F,";")self:check_match(F,"}","{",bf)self:lastlistfield(aq,bA)d:SETARG_B(aq.f.code[aC],self:int2fb(bA.na))d:SETARG_C(aq.f.code[aC],self:int2fb(bA.nh))end;function b:parlist(F)local aq=F.fs;local am=aq.f;local bD=0;am.is_vararg=0;if F.t.token~=")"then repeat local M=F.t.token;if M=="TK_NAME"then self:new_localvar(F,self:str_checkname(F),bD)bD=bD+1 elseif M=="TK_DOTS"then c:next(F)self:new_localvarliteral(F,"arg",bD)bD=bD+1;am.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;am.is_vararg=am.is_vararg+self.VARARG_ISVARARG else c:syntaxerror(F,"<name> or "..self:LUA_QL("...").." expected")end until am.is_vararg~=0 or not self:testnext(F,",")end;self:adjustlocalvars(F,bD)am.numparams=aq.nactvar-am.is_vararg%self.HASARG_MASK;f:reserveregs(aq,aq.nactvar)end;function b:body(F,ar,bE,bf)local bF={}bF.upvalues={}bF.actvar={}self:open_func(F,bF)bF.f.lineDefined=bf;self:checknext(F,"(")if bE then self:new_localvarliteral(F,"self",0)self:adjustlocalvars(F,1)end;self:parlist(F)self:checknext(F,")")self:chunk(F)bF.f.lastlinedefined=F.linenumber;self:check_match(F,"TK_END","TK_FUNCTION",bf)self:close_func(F)self:pushclosure(F,bF,ar)end;function b:explist1(F,v)local r=1;self:expr(F,v)while self:testnext(F,",")do f:exp2nextreg(F.fs,v)self:expr(F,v)r=r+1 end;return r end;function b:funcargs(F,am)local aq=F.fs;local bG={}local bD;local bf=F.linenumber;local M=F.t.token;if M=="("then if bf~=F.lastline then c:syntaxerror(F,"ambiguous syntax (function call x new statement)")end;c:next(F)if F.t.token==")"then bG.k="VVOID"else self:explist1(F,bG)f:setmultret(aq,bG)end;self:check_match(F,")","(",bf)elseif M=="{"then self:constructor(F,bG)elseif M=="TK_STRING"then self:codestring(F,bG,F.t.seminfo)c:next(F)else c:syntaxerror(F,"function arguments expected")return end;h(am.k=="VNONRELOC")local bg=am.info;if self:hasmultret(bG.k)then bD=self.LUA_MULTRET else if bG.k~="VVOID"then f:exp2nextreg(aq,bG)end;bD=aq.freereg-(bg+1)end;self:init_exp(am,"VCALL",f:codeABC(aq,"OP_CALL",bg,bD+1,2))f:fixline(aq,bf)aq.freereg=bg+1 end;function b:prefixexp(F,v)local M=F.t.token;if M=="("then local bf=F.linenumber;c:next(F)self:expr(F,v)self:check_match(F,")","(",bf)f:dischargevars(F.fs,v)elseif M=="TK_NAME"then self:singlevar(F,v)else c:syntaxerror(F,"unexpected symbol")end;return end;function b:primaryexp(F,v)local aq=F.fs;self:prefixexp(F,v)while true do local M=F.t.token;if M=="."then self:field(F,v)elseif M=="["then local b2={}f:exp2anyreg(aq,v)self:yindex(F,b2)f:indexed(aq,v,b2)elseif M==":"then local b2={}c:next(F)self:checkname(F,b2)f:_self(aq,v,b2)self:funcargs(F,v)elseif M=="("or M=="TK_STRING"or M=="{"then f:exp2nextreg(aq,v)self:funcargs(F,v)else return end end end;function b:simpleexp(F,v)local M=F.t.token;if M=="TK_NUMBER"then self:init_exp(v,"VKNUM",0)v.nval=F.t.seminfo elseif M=="TK_STRING"then self:codestring(F,v,F.t.seminfo)elseif M=="TK_NIL"then self:init_exp(v,"VNIL",0)elseif M=="TK_TRUE"then self:init_exp(v,"VTRUE",0)elseif M=="TK_FALSE"then self:init_exp(v,"VFALSE",0)elseif M=="TK_DOTS"then local aq=F.fs;self:check_condition(F,aq.f.is_vararg~=0,"cannot use "..self:LUA_QL("...").." outside a vararg function")local bH=aq.f.is_vararg;if bH>=self.VARARG_NEEDSARG then aq.f.is_vararg=bH-self.VARARG_NEEDSARG end;self:init_exp(v,"VVARARG",f:codeABC(aq,"OP_VARARG",0,1,0))elseif M=="{"then self:constructor(F,v)return elseif M=="TK_FUNCTION"then c:next(F)self:body(F,v,false,F.linenumber)return else self:primaryexp(F,v)return end;c:next(F)end;function b:getunopr(a8)if a8=="TK_NOT"then return"OPR_NOT"elseif a8=="-"then return"OPR_MINUS"elseif a8=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;b.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function b:getbinopr(a8)local bI=self.getbinopr_table[a8]if bI then return bI else return"OPR_NOBINOPR"end end;b.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}b.UNARY_PRIORITY=8;function b:subexpr(F,v,bk)self:enterlevel(F)local bJ=self:getunopr(F.t.token)if bJ~="OPR_NOUNOPR"then c:next(F)self:subexpr(F,v,self.UNARY_PRIORITY)f:prefix(F.fs,bJ,v)else self:simpleexp(F,v)end;local a8=self:getbinopr(F.t.token)while a8~="OPR_NOBINOPR"and self.priority[f.BinOpr[a8]+1][1]>bk do local b9={}c:next(F)f:infix(F.fs,a8,v)local bK=self:subexpr(F,b9,self.priority[f.BinOpr[a8]+1][2])f:posfix(F.fs,a8,v,b9)a8=bK end;self:leavelevel(F)return a8 end;function b:expr(F,v)self:subexpr(F,v,0)end;function b:block_follow(G)if G=="TK_ELSE"or G=="TK_ELSEIF"or G=="TK_END"or G=="TK_UNTIL"or G=="TK_EOS"then return true else return false end end;function b:block(F)local aq=F.fs;local bu={}self:enterblock(aq,bu,false)self:chunk(F)h(bu.breaklist==f.NO_JUMP)self:leaveblock(aq)end;function b:check_conflict(F,bL,v)local aq=F.fs;local bw=aq.freereg;local bM=false;while bL do if bL.v.k=="VINDEXED"then if bL.v.info==v.info then bM=true;bL.v.info=bw end;if bL.v.aux==v.info then bM=true;bL.v.aux=bw end end;bL=bL.prev end;if bM then f:codeABC(aq,"OP_MOVE",aq.freereg,v.info,0)f:reserveregs(aq,1)end end;function b:assignment(F,bL,bq)local ar={}local M=bL.v.k;self:check_condition(F,M=="VLOCAL"or M=="VUPVAL"or M=="VGLOBAL"or M=="VINDEXED","syntax error")if self:testnext(F,",")then local bN={}bN.v={}bN.prev=bL;self:primaryexp(F,bN.v)if bN.v.k=="VLOCAL"then self:check_conflict(F,bL,bN.v)end;self:checklimit(F.fs,bq,self.LUAI_MAXCCALLS-F.L.nCcalls,"variables in assignment")self:assignment(F,bN,bq+1)else self:checknext(F,"=")local bv=self:explist1(F,ar)if bv~=bq then self:adjust_assign(F,bq,bv,ar)if bv>bq then F.fs.freereg=F.fs.freereg-(bv-bq)end else f:setoneret(F.fs,ar)f:storevar(F.fs,bL.v,ar)return end end;self:init_exp(ar,"VNONRELOC",F.fs.freereg-1)f:storevar(F.fs,bL.v,ar)end;function b:cond(F)local v={}self:expr(F,v)if v.k=="VNIL"then v.k="VFALSE"end;f:goiftrue(F.fs,v)return v.f end;function b:breakstat(F)local aq=F.fs;local bu=aq.bl;local bO=false;while bu and not bu.isbreakable do if bu.upval then bO=true end;bu=bu.previous end;if not bu then c:syntaxerror(F,"no loop to break")end;if bO then f:codeABC(aq,"OP_CLOSE",bu.nactvar,0,0)end;bu.breaklist=f:concat(aq,bu.breaklist,f:jump(aq))end;function b:whilestat(F,bf)local aq=F.fs;local bu={}c:next(F)local bP=f:getlabel(aq)local bQ=self:cond(F)self:enterblock(aq,bu,true)self:checknext(F,"TK_DO")self:block(F)f:patchlist(aq,f:jump(aq),bP)self:check_match(F,"TK_END","TK_WHILE",bf)self:leaveblock(aq)f:patchtohere(aq,bQ)end;function b:repeatstat(F,bf)local aq=F.fs;local bR=f:getlabel(aq)local bS,bT={},{}self:enterblock(aq,bS,true)self:enterblock(aq,bT,false)c:next(F)self:chunk(F)self:check_match(F,"TK_UNTIL","TK_REPEAT",bf)local bQ=self:cond(F)if not bT.upval then self:leaveblock(aq)f:patchlist(F.fs,bQ,bR)else self:breakstat(F)f:patchtohere(F.fs,bQ)self:leaveblock(aq)f:patchlist(F.fs,f:jump(aq),bR)end;self:leaveblock(aq)end;function b:exp1(F)local ar={}self:expr(F,ar)local aS=ar.k;f:exp2nextreg(F.fs,ar)return aS end;function b:forbody(F,bg,bf,bq,bU)local bu={}local aq=F.fs;self:adjustlocalvars(F,3)self:checknext(F,"TK_DO")local bV=bU and f:codeAsBx(aq,"OP_FORPREP",bg,f.NO_JUMP)or f:jump(aq)self:enterblock(aq,bu,false)self:adjustlocalvars(F,bq)f:reserveregs(aq,bq)self:block(F)self:leaveblock(aq)f:patchtohere(aq,bV)local bW=bU and f:codeAsBx(aq,"OP_FORLOOP",bg,f.NO_JUMP)or f:codeABC(aq,"OP_TFORLOOP",bg,0,bq)f:fixline(aq,bf)f:patchlist(aq,bU and bW or f:jump(aq),bV+1)end;function b:fornum(F,bo,bf)local aq=F.fs;local bg=aq.freereg;self:new_localvarliteral(F,"(for index)",0)self:new_localvarliteral(F,"(for limit)",1)self:new_localvarliteral(F,"(for step)",2)self:new_localvar(F,bo,3)self:checknext(F,'=')self:exp1(F)self:checknext(F,",")self:exp1(F)if self:testnext(F,",")then self:exp1(F)else f:codeABx(aq,"OP_LOADK",aq.freereg,f:numberK(aq,1))f:reserveregs(aq,1)end;self:forbody(F,bg,bf,1,true)end;function b:forlist(F,bX)local aq=F.fs;local ar={}local bq=0;local bg=aq.freereg;self:new_localvarliteral(F,"(for generator)",bq)bq=bq+1;self:new_localvarliteral(F,"(for state)",bq)bq=bq+1;self:new_localvarliteral(F,"(for control)",bq)bq=bq+1;self:new_localvar(F,bX,bq)bq=bq+1;while self:testnext(F,",")do self:new_localvar(F,self:str_checkname(F),bq)bq=bq+1 end;self:checknext(F,"TK_IN")local bf=F.linenumber;self:adjust_assign(F,3,self:explist1(F,ar),ar)f:checkstack(aq,3)self:forbody(F,bg,bf,bq-3,false)end;function b:forstat(F,bf)local aq=F.fs;local bu={}self:enterblock(aq,bu,true)c:next(F)local bo=self:str_checkname(F)local M=F.t.token;if M=="="then self:fornum(F,bo,bf)elseif M==","or M=="TK_IN"then self:forlist(F,bo)else c:syntaxerror(F,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(F,"TK_END","TK_FOR",bf)self:leaveblock(aq)end;function b:test_then_block(F)c:next(F)local bQ=self:cond(F)self:checknext(F,"TK_THEN")self:block(F)return bQ end;function b:ifstat(F,bf)local aq=F.fs;local bY=f.NO_JUMP;local bZ=self:test_then_block(F)while F.t.token=="TK_ELSEIF"do bY=f:concat(aq,bY,f:jump(aq))f:patchtohere(aq,bZ)bZ=self:test_then_block(F)end;if F.t.token=="TK_ELSE"then bY=f:concat(aq,bY,f:jump(aq))f:patchtohere(aq,bZ)c:next(F)self:block(F)else bY=f:concat(aq,bY,bZ)end;f:patchtohere(aq,bY)self:check_match(F,"TK_END","TK_IF",bf)end;function b:localfunc(F)local v,k={},{}local aq=F.fs;self:new_localvar(F,self:str_checkname(F),0)self:init_exp(v,"VLOCAL",aq.freereg)f:reserveregs(aq,1)self:adjustlocalvars(F,1)self:body(F,k,false,F.linenumber)f:storevar(aq,v,k)self:getlocvar(aq,aq.nactvar-1).startpc=aq.pc end;function b:localstat(F)local bq=0;local bv;local ar={}repeat self:new_localvar(F,self:str_checkname(F),bq)bq=bq+1 until not self:testnext(F,",")if self:testnext(F,"=")then bv=self:explist1(F,ar)else ar.k="VVOID"bv=0 end;self:adjust_assign(F,bq,bv,ar)self:adjustlocalvars(F,bq)end;function b:funcname(F,v)local bE=false;self:singlevar(F,v)while F.t.token=="."do self:field(F,v)end;if F.t.token==":"then bE=true;self:field(F,v)end;return bE end;function b:funcstat(F,bf)local v,k={},{}c:next(F)local bE=self:funcname(F,v)self:body(F,k,bE,bf)f:storevar(F.fs,v,k)f:fixline(F.fs,bf)end;function b:exprstat(F)local aq=F.fs;local v={}v.v={}self:primaryexp(F,v.v)if v.v.k=="VCALL"then d:SETARG_C(f:getcode(aq,v.v),1)else v.prev=nil;self:assignment(F,v,1)end end;function b:retstat(F)local aq=F.fs;local ar={}local C,az;c:next(F)if self:block_follow(F.t.token)or F.t.token==";"then C,az=0,0 else az=self:explist1(F,ar)if self:hasmultret(ar.k)then f:setmultret(aq,ar)if ar.k=="VCALL"and az==1 then d:SET_OPCODE(f:getcode(aq,ar),"OP_TAILCALL")h(d:GETARG_A(f:getcode(aq,ar))==aq.nactvar)end;C=aq.nactvar;az=self.LUA_MULTRET else if az==1 then C=f:exp2anyreg(aq,ar)else f:exp2nextreg(aq,ar)C=aq.nactvar;h(az==aq.freereg-C)end end end;f:ret(aq,C,az)end;function b:statement(F)local bf=F.linenumber;local M=F.t.token;if M=="TK_IF"then self:ifstat(F,bf)return false elseif M=="TK_WHILE"then self:whilestat(F,bf)return false elseif M=="TK_DO"then c:next(F)self:block(F)self:check_match(F,"TK_END","TK_DO",bf)return false elseif M=="TK_FOR"then self:forstat(F,bf)return false elseif M=="TK_REPEAT"then self:repeatstat(F,bf)return false elseif M=="TK_FUNCTION"then self:funcstat(F,bf)return false elseif M=="TK_LOCAL"then c:next(F)if self:testnext(F,"TK_FUNCTION")then self:localfunc(F)else self:localstat(F)end;return false elseif M=="TK_RETURN"then self:retstat(F)return true elseif M=="TK_BREAK"then c:next(F)self:breakstat(F)return true else self:exprstat(F)return false end end;function b:chunk(F)local b_=false;self:enterlevel(F)while not b_ and not self:block_follow(F.t.token)do b_=self:statement(F)self:testnext(F,";")h(F.fs.f.maxstacksize>=F.fs.freereg and F.fs.freereg>=F.fs.nactvar)F.fs.freereg=F.fs.nactvar end;self:leavelevel(F)end;c:init()local c0={}return function(m,name)name=name or'compiled-lua'local c1=a:init(a:make_getF(m),nil)if not c1 then return end;local b3=b:parser(c0,c1,nil,"@"..name)local ad,j=e:make_setS()e:dump(c0,b3,ad,j)return j.data end end)(),
	FiOne = (function()if not bit then local bit_ = nil pcall(function()bit_=require('bit') end)bit=bit_ end local bit=bit or bit32 or(function()local a={_TYPE='module',_NAME='bit.numberlua',_VERSION='0.3.1.20120131'}local b=math.floor;local c=2^32;local d=c-1;local function e(f)local g={}local h=setmetatable({},g)function g:__index(i)local j=f(i)h[i]=j;return j end;return h end;local function k(h,l)local function m(n,o)local p,q=0,1;while n~=0 and o~=0 do local r,s=n%l,o%l;p=p+h[r][s]*q;n=(n-r)/l;o=(o-s)/l;q=q*l end;p=p+(n+o)*q;return p end;return m end;local function t(h)local u=k(h,2^1)local v=e(function(n)return e(function(o)return u(n,o)end)end)return k(v,2^(h.n or 1))end;function a.tobit(w)return w%2^32 end;a.bxor=t{[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0},n=4}local x=a.bxor;function a.bnot(n)return d-n end;local y=a.bnot;function a.band(n,o)return(n+o-x(n,o))/2 end;local z=a.band;function a.bor(n,o)return d-z(d-n,d-o)end;local A=a.bor;local B,C;function a.rshift(n,D)if D<0 then return B(n,-D)end;return b(n%2^32/2^D)end;C=a.rshift;function a.lshift(n,D)if D<0 then return C(n,-D)end;return n*2^D%2^32 end;B=a.lshift;function a.tohex(w,E)E=E or 8;local F;if E<=0 then if E==0 then return''end;F=true;E=-E end;w=z(w,16^E-1)return('%0'..E..(F and'X'or'x')):format(w)end;local G=a.tohex;function a.extract(E,H,I)I=I or 1;return z(C(E,H),2^I-1)end;local J=a.extract;function a.replace(E,j,H,I)I=I or 1;local K=2^I-1;j=z(j,K)local L=y(B(K,H))return z(E,L)+B(j,H)end;local M=a.replace;function a.bswap(w)local n=z(w,0xff)w=C(w,8)local o=z(w,0xff)w=C(w,8)local N=z(w,0xff)w=C(w,8)local O=z(w,0xff)return B(B(B(n,8)+o,8)+N,8)+O end;local P=a.bswap;function a.rrotate(w,D)D=D%32;local Q=z(w,2^D-1)return C(w,D)+B(Q,32-D)end;local R=a.rrotate;function a.lrotate(w,D)return R(w,-D)end;local S=a.lrotate;a.rol=a.lrotate;a.ror=a.rrotate;function a.arshift(w,D)local T=C(w,D)if w>=0x80000000 then T=T+B(2^D-1,32-D)end;return T end;local U=a.arshift;function a.btest(w,V)return z(w,V)~=0 end;a.bit32={}local function W(w)return(-1-w)%c end;a.bit32.bnot=W;local function X(n,o,N,...)local T;if o then n=n%c;o=o%c;T=x(n,o)if N then T=X(T,N,...)end;return T elseif n then return n%c else return 0 end end;a.bit32.bxor=X;local function Y(n,o,N,...)local T;if o then n=n%c;o=o%c;T=(n+o-x(n,o))/2;if N then T=Y(T,N,...)end;return T elseif n then return n%c else return d end end;a.bit32.band=Y;local function Z(n,o,N,...)local T;if o then n=n%c;o=o%c;T=d-z(d-n,d-o)if N then T=Z(T,N,...)end;return T elseif n then return n%c else return 0 end end;a.bit32.bor=Z;function a.bit32.btest(...)return Y(...)~=0 end;function a.bit32.lrotate(w,D)return S(w%c,D)end;function a.bit32.rrotate(w,D)return R(w%c,D)end;function a.bit32.lshift(w,D)if D>31 or D<-31 then return 0 end;return B(w%c,D)end;function a.bit32.rshift(w,D)if D>31 or D<-31 then return 0 end;return C(w%c,D)end;function a.bit32.arshift(w,D)w=w%c;if D>=0 then if D>31 then return w>=0x80000000 and d or 0 else local T=C(w,D)if w>=0x80000000 then T=T+B(2^D-1,32-D)end;return T end else return B(w,-D)end end;function a.bit32.extract(w,H,...)local I=...or 1;if H<0 or H>31 or I<0 or H+I>32 then error'out of range'end;w=w%c;return J(w,H,...)end;function a.bit32.replace(w,j,H,...)local I=...or 1;if H<0 or H>31 or I<0 or H+I>32 then error'out of range'end;w=w%c;j=j%c;return M(w,j,H,...)end;a.bit={}function a.bit.tobit(w)w=w%c;if w>=0x80000000 then w=w-c end;return w end;local _=a.bit.tobit;function a.bit.tohex(w,...)return G(w%c,...)end;function a.bit.bnot(w)return _(y(w%c))end;local function a0(n,o,N,...)if N then return a0(a0(n,o),N,...)elseif o then return _(A(n%c,o%c))else return _(n)end end;a.bit.bor=a0;local function a1(n,o,N,...)if N then return a1(a1(n,o),N,...)elseif o then return _(z(n%c,o%c))else return _(n)end end;a.bit.band=a1;local function a2(n,o,N,...)if N then return a2(a2(n,o),N,...)elseif o then return _(x(n%c,o%c))else return _(n)end end;a.bit.bxor=a2;function a.bit.lshift(w,E)return _(B(w%c,E%32))end;function a.bit.rshift(w,E)return _(C(w%c,E%32))end;function a.bit.arshift(w,E)return _(U(w%c,E%32))end;function a.bit.rol(w,E)return _(S(w%c,E%32))end;function a.bit.ror(w,E)return _(R(w%c,E%32))end;function a.bit.bswap(w)return _(P(w%c))end;return a end)()local unpack=table.unpack or unpack;local a3;local a4;local a5;local a6=50;local a7={[22]=18,[31]=8,[33]=28,[0]=3,[1]=13,[2]=23,[26]=33,[12]=1,[13]=6,[14]=10,[15]=16,[16]=20,[17]=26,[18]=30,[19]=36,[3]=0,[4]=2,[5]=4,[6]=7,[7]=9,[8]=12,[9]=14,[10]=17,[20]=19,[21]=22,[23]=24,[24]=27,[25]=29,[27]=32,[32]=34,[34]=37,[11]=5,[28]=11,[29]=15,[30]=21,[35]=25,[36]=31,[37]=35}local a8={[0]='ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local a9={[0]={b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgR'},{b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgU'},{b='OpArgR',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgN',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgN',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgU',c='OpArgN'}}local function aa(ab,s,e,d)local ac=0;for i=s,e,d do ac=ac+string.byte(ab,i,i)*256^(i-s)end;return ac end;local function ad(ae,af,ag,ah)local ai=(-1)^bit.rshift(ah,7)local aj=bit.rshift(ag,7)+bit.lshift(bit.band(ah,0x7F),1)local ak=ae+bit.lshift(af,8)+bit.lshift(bit.band(ag,0x7F),16)local al=1;if aj==0 then if ak==0 then return ai*0 else al=0;aj=1 end elseif aj==0x7F then if ak==0 then return ai*1/0 else return ai*0/0 end end;return ai*2^(aj-127)*(1+al/2^23)end;local function am(ae,af,ag,ah,an,ao,ap,aq)local ai=(-1)^bit.rshift(aq,7)local aj=bit.lshift(bit.band(aq,0x7F),4)+bit.rshift(ap,4)local ak=bit.band(ap,0x0F)*2^48;local al=1;ak=ak+ao*2^40+an*2^32+ah*2^24+ag*2^16+af*2^8+ae;if aj==0 then if ak==0 then return ai*0 else al=0;aj=1 end elseif aj==0x7FF then if ak==0 then return ai*1/0 else return ai*0/0 end end;return ai*2^(aj-1023)*(al+ak/2^52)end;local function ar(ab,s,e)return aa(ab,s,e-1,1)end;local function as(ab,s,e)return aa(ab,e-1,s,-1)end;local function at(ab,s)return ad(string.byte(ab,s,s+3))end;local function au(ab,s)local ae,af,ag,ah=string.byte(ab,s,s+3)return ad(ah,ag,af,ae)end;local function av(ab,s)return am(string.byte(ab,s,s+7))end;local function aw(ab,s)local ae,af,ag,ah,an,ao,ap,aq=string.byte(ab,s,s+7)return am(aq,ap,ao,an,ah,ag,af,ae)end;local ax={[4]={little=at,big=au},[8]={little=av,big=aw}}local function ay(S)local az=S.index;local aA=string.byte(S.source,az,az)S.index=az+1;return aA end;local function aB(S,aC)local aD=S.index+aC;local aE=string.sub(S.source,S.index,aD-1)S.index=aD;return aE end;local function aF(S)local aC=S:s_szt()local aE;if aC~=0 then aE=string.sub(aB(S,aC),1,-2)end;return aE end;local function aG(aC,aH)return function(S)local aD=S.index+aC;local aI=aH(S.source,S.index,aD)S.index=aD;return aI end end;local function aJ(aC,aH)return function(S)local aK=aH(S.source,S.index)S.index=S.index+aC;return aK end end;local function aL(S)local aM=S:s_int()local aN={}for i=1,aM do local aO=S:s_ins()local aP=bit.band(aO,0x3F)local aQ=a8[aP]local aR=a9[aP]local aS={value=aO,op=a7[aP],A=bit.band(bit.rshift(aO,6),0xFF)}if aQ=='ABC'then aS.B=bit.band(bit.rshift(aO,23),0x1FF)aS.C=bit.band(bit.rshift(aO,14),0x1FF)aS.is_KB=aR.b=='OpArgK'and aS.B>0xFF;aS.is_KC=aR.c=='OpArgK'and aS.C>0xFF elseif aQ=='ABx'then aS.Bx=bit.band(bit.rshift(aO,14),0x3FFFF)aS.is_K=aR.b=='OpArgK'elseif aQ=='AsBx'then aS.sBx=bit.band(bit.rshift(aO,14),0x3FFFF)-131071 end;aN[i]=aS end;return aN end;local function aT(S)local aM=S:s_int()local aU={}for i=1,aM do local aV=ay(S)local k;if aV==1 then k=ay(S)~=0 elseif aV==3 then k=S:s_num()elseif aV==4 then k=aF(S)end;aU[i]=k end;return aU end;local function aW(S,ab)local aM=S:s_int()local aX={}for i=1,aM do aX[i]=a5(S,ab)end;return aX end;local function aY(S)local aM=S:s_int()local aZ={}for i=1,aM do aZ[i]=S:s_int()end;return aZ end;local function a_(S)local aM=S:s_int()local b0={}for i=1,aM do b0[i]={varname=aF(S),startpc=S:s_int(),endpc=S:s_int()}end;return b0 end;local function b1(S)local aM=S:s_int()local b2={}for i=1,aM do b2[i]=aF(S)end;return b2 end;function a5(S,b3)local b4={}local ab=aF(S)or b3;b4.source=ab;S:s_int()S:s_int()b4.numupvals=ay(S)b4.numparams=ay(S)ay(S)ay(S)b4.code=aL(S)b4.const=aT(S)b4.subs=aW(S,ab)b4.lines=aY(S)a_(S)b1(S)for _,v in ipairs(b4.code)do if v.is_K then v.const=b4.const[v.Bx+1]else if v.is_KB then v.const_B=b4.const[v.B-0xFF]end;if v.is_KC then v.const_C=b4.const[v.C-0xFF]end end end;return b4 end;function a3(ab)local b5;local b6;local b7;local b8;local b9;local ba;local bb;local bc={index=1,source=ab}assert(aB(bc,4)=='\27Lua','invalid Lua signature')assert(ay(bc)==0x51,'invalid Lua version')assert(ay(bc)==0,'invalid Lua format')b6=ay(bc)~=0;b7=ay(bc)b8=ay(bc)b9=ay(bc)ba=ay(bc)bb=ay(bc)~=0;b5=b6 and ar or as;bc.s_int=aG(b7,b5)bc.s_szt=aG(b8,b5)bc.s_ins=aG(b9,b5)if bb then bc.s_num=aG(ba,b5)elseif ax[ba]then bc.s_num=aJ(ba,ax[ba][b6 and'little'or'big'])else error('unsupported float size')end;return a5(bc,'@virtual')end;local function bd(be,bf)for i,bg in pairs(be)do if bg.index>=bf then bg.value=bg.store[bg.index]bg.store=bg;bg.index='value'be[i]=nil end end end;local function bh(be,bf,bi)local bj=be[bf]if not bj then bj={index=bf,store=bi}be[bf]=bj end;return bj end;local function bk(...)return select('#',...),{...}end;local function bl(bm,bn)local ab=bm.source;local bo=bm.lines[bm.pc-1]local b3,bp,bq=string.match(bn,'^(.-):(%d+):%s+(.+)')local br='%s:%i: [%s:%i] %s'bo=bo or'0'b3=b3 or'?'bp=bp or'0'bq=bq or bn;error(string.format(br,ab,bo,b3,bp,bq),0)end;local function bs(bm)local aN=bm.code;local bt=bm.subs;local bu=bm.env;local bv=bm.upvals;local bw=bm.varargs;local bx=-1;local by={}local bi=bm.stack;local bz=bm.pc;while true do local bA=aN[bz]local aP=bA.op;bz=bz+1;if aP<18 then if aP<8 then if aP<3 then if aP<1 then for i=bA.A,bA.B do bi[i]=nil end elseif aP>1 then local bg=bv[bA.B]bi[bA.A]=bg.store[bg.index]else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB+bC end elseif aP>3 then if aP<6 then if aP>4 then local A=bA.A;local B=bA.B;local bf;if bA.is_KC then bf=bA.const_C else bf=bi[bA.C]end;bi[A+1]=bi[B]bi[A]=bi[B][bf]else bi[bA.A]=bu[bA.const]end elseif aP>6 then local bf;if bA.is_KC then bf=bA.const_C else bf=bi[bA.C]end;bi[bA.A]=bi[bA.B][bf]else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB-bC end else bi[bA.A]=bi[bA.B]end elseif aP>8 then if aP<13 then if aP<10 then bu[bA.const]=bi[bA.A]elseif aP>10 then if aP<12 then local A=bA.A;local B=bA.B;local C=bA.C;local bD;local bE,bF;if B==0 then bD=bx-A else bD=B-1 end;bE,bF=bk(bi[A](unpack(bi,A+1,A+bD)))if C==0 then bx=A+bE-1 else bE=C-1 end;for i=1,bE do bi[A+i-1]=bF[i]end else local bg=bv[bA.B]bg.store[bg.index]=bi[bA.A]end else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB*bC end elseif aP>13 then if aP<16 then if aP>14 then local A=bA.A;local B=bA.B;local bD;if B==0 then bD=bx-A else bD=B-1 end;bd(by,0)return bk(bi[A](unpack(bi,A+1,A+bD)))else local bf,bG;if bA.is_KB then bf=bA.const_B else bf=bi[bA.B]end;if bA.is_KC then bG=bA.const_C else bG=bi[bA.C]end;bi[bA.A][bf]=bG end elseif aP>16 then bi[bA.A]={}else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB/bC end else bi[bA.A]=bA.const end else local A=bA.A;local bH=bi[A+2]local bf=bi[A]+bH;local bI=bi[A+1]local bJ;if bH==math.abs(bH)then bJ=bf<=bI else bJ=bf>=bI end;if bJ then bi[bA.A]=bf;bi[bA.A+3]=bf;bz=bz+bA.sBx end end elseif aP>18 then if aP<28 then if aP<23 then if aP<20 then bi[bA.A]=#bi[bA.B]elseif aP>20 then if aP<22 then local A=bA.A;local B=bA.B;local bK={}local aM;if B==0 then aM=bx-A+1 else aM=B-1 end;for i=1,aM do bK[i]=bi[A+i-1]end;bd(by,0)return aM,bK else local aE=bi[bA.B]for i=bA.B+1,bA.C do aE=aE..bi[i]end;bi[bA.A]=aE end else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB%bC end elseif aP>23 then if aP<26 then if aP>24 then bd(by,bA.A)else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;if bB==bC==(bA.A~=0)then bz=bz+aN[bz].sBx end;bz=bz+1 end elseif aP>26 then local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;if bB<bC==(bA.A~=0)then bz=bz+aN[bz].sBx end;bz=bz+1 else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB^bC end else bi[bA.A]=bA.B~=0;if bA.C~=0 then bz=bz+1 end end elseif aP>28 then if aP<33 then if aP<30 then local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;if bB<=bC==(bA.A~=0)then bz=bz+aN[bz].sBx end;bz=bz+1 elseif aP>30 then if aP<32 then local aX=bt[bA.Bx+1]local bL=aX.numupvals;local bM;if bL~=0 then bM={}for i=1,bL do local bN=aN[bz+i-1]if bN.op==a7[0]then bM[i-1]=bh(by,bN.B,bi)elseif bN.op==a7[4]then bM[i-1]=bv[bN.B]end end;bz=bz+bL end;bi[bA.A]=a4(aX,bu,bM)else local A=bA.A;local B=bA.B;if not bi[B]==(bA.C~=0)then bz=bz+1 else bi[A]=bi[B]end end else bi[bA.A]=-bi[bA.B]end elseif aP>33 then if aP<36 then if aP>34 then local A=bA.A;local aM=bA.B;if aM==0 then aM=bw.size;bx=A+aM-1 end;for i=1,aM do bi[A+i-1]=bw.list[i]end else local A=bA.A;local bO,bI,bH;bO=assert(tonumber(bi[A]),'`for` initial value must be a number')bI=assert(tonumber(bi[A+1]),'`for` limit must be a number')bH=assert(tonumber(bi[A+2]),'`for` step must be a number')bi[A]=bO-bH;bi[A+1]=bI;bi[A+2]=bH;bz=bz+bA.sBx end elseif aP>36 then local A=bA.A;local C=bA.C;local aM=bA.B;local bP=bi[A]local bQ;if aM==0 then aM=bx-A end;if C==0 then C=bA[bz].value;bz=bz+1 end;bQ=(C-1)*a6;for i=1,aM do bP[i+bQ]=bi[A+i]end else bi[bA.A]=not bi[bA.B]end else if not bi[bA.A]==(bA.C~=0)then bz=bz+1 end end else local A=bA.A;local aH=bi[A]local bR=bi[A+1]local bf=bi[A+2]local bS=A+3;local bK;bi[bS+2]=bf;bi[bS+1]=bR;bi[bS]=aH;bK={aH(bR,bf)}for i=1,bA.C do bi[bS+i-1]=bK[i]end;if bi[bS]~=nil then bi[A+2]=bi[bS]else bz=bz+1 end end else bz=bz+bA.sBx end;bm.pc=bz end end;function a4(bR,bu,b2)local bT=bR.code;local bU=bR.subs;local bV=bR.lines;local bW=bR.source;local bX=bR.numparams;local function bY(...)local bi={}local bZ={}local b_=0;local c0,c1=bk(...)local bm;local c2,bn,bK;for i=1,bX do bi[i-1]=c1[i]end;if bX<c0 then b_=c0-bX;for i=1,b_ do bZ[i]=c1[bX+i]end end;bm={varargs={list=bZ,size=b_},code=bT,subs=bU,lines=bV,source=bW,env=bu,upvals=b2,stack=bi,pc=1}c2,bn,bK=pcall(bs,bm,...)if c2 then return unpack(bK,1,bn)else bl(bm,bn)end;return end;return bY end;return function(c3,bu)return a4(a3(c3),bu or fenv(0))end end)(),
	FiOneCode = [==[(function()if not bit then local bit_=nil pcall(function()bit_=require('bit') end)bit=bit_ end local bit=bit or bit32 or(function()local a={_TYPE='module',_NAME='bit.numberlua',_VERSION='0.3.1.20120131'}local b=math.floor;local c=2^32;local d=c-1;local function e(f)local g={}local h=setmetatable({},g)function g:__index(i)local j=f(i)h[i]=j;return j end;return h end;local function k(h,l)local function m(n,o)local p,q=0,1;while n~=0 and o~=0 do local r,s=n%l,o%l;p=p+h[r][s]*q;n=(n-r)/l;o=(o-s)/l;q=q*l end;p=p+(n+o)*q;return p end;return m end;local function t(h)local u=k(h,2^1)local v=e(function(n)return e(function(o)return u(n,o)end)end)return k(v,2^(h.n or 1))end;function a.tobit(w)return w%2^32 end;a.bxor=t{[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0},n=4}local x=a.bxor;function a.bnot(n)return d-n end;local y=a.bnot;function a.band(n,o)return(n+o-x(n,o))/2 end;local z=a.band;function a.bor(n,o)return d-z(d-n,d-o)end;local A=a.bor;local B,C;function a.rshift(n,D)if D<0 then return B(n,-D)end;return b(n%2^32/2^D)end;C=a.rshift;function a.lshift(n,D)if D<0 then return C(n,-D)end;return n*2^D%2^32 end;B=a.lshift;function a.tohex(w,E)E=E or 8;local F;if E<=0 then if E==0 then return''end;F=true;E=-E end;w=z(w,16^E-1)return('%0'..E..(F and'X'or'x')):format(w)end;local G=a.tohex;function a.extract(E,H,I)I=I or 1;return z(C(E,H),2^I-1)end;local J=a.extract;function a.replace(E,j,H,I)I=I or 1;local K=2^I-1;j=z(j,K)local L=y(B(K,H))return z(E,L)+B(j,H)end;local M=a.replace;function a.bswap(w)local n=z(w,0xff)w=C(w,8)local o=z(w,0xff)w=C(w,8)local N=z(w,0xff)w=C(w,8)local O=z(w,0xff)return B(B(B(n,8)+o,8)+N,8)+O end;local P=a.bswap;function a.rrotate(w,D)D=D%32;local Q=z(w,2^D-1)return C(w,D)+B(Q,32-D)end;local R=a.rrotate;function a.lrotate(w,D)return R(w,-D)end;local S=a.lrotate;a.rol=a.lrotate;a.ror=a.rrotate;function a.arshift(w,D)local T=C(w,D)if w>=0x80000000 then T=T+B(2^D-1,32-D)end;return T end;local U=a.arshift;function a.btest(w,V)return z(w,V)~=0 end;a.bit32={}local function W(w)return(-1-w)%c end;a.bit32.bnot=W;local function X(n,o,N,...)local T;if o then n=n%c;o=o%c;T=x(n,o)if N then T=X(T,N,...)end;return T elseif n then return n%c else return 0 end end;a.bit32.bxor=X;local function Y(n,o,N,...)local T;if o then n=n%c;o=o%c;T=(n+o-x(n,o))/2;if N then T=Y(T,N,...)end;return T elseif n then return n%c else return d end end;a.bit32.band=Y;local function Z(n,o,N,...)local T;if o then n=n%c;o=o%c;T=d-z(d-n,d-o)if N then T=Z(T,N,...)end;return T elseif n then return n%c else return 0 end end;a.bit32.bor=Z;function a.bit32.btest(...)return Y(...)~=0 end;function a.bit32.lrotate(w,D)return S(w%c,D)end;function a.bit32.rrotate(w,D)return R(w%c,D)end;function a.bit32.lshift(w,D)if D>31 or D<-31 then return 0 end;return B(w%c,D)end;function a.bit32.rshift(w,D)if D>31 or D<-31 then return 0 end;return C(w%c,D)end;function a.bit32.arshift(w,D)w=w%c;if D>=0 then if D>31 then return w>=0x80000000 and d or 0 else local T=C(w,D)if w>=0x80000000 then T=T+B(2^D-1,32-D)end;return T end else return B(w,-D)end end;function a.bit32.extract(w,H,...)local I=...or 1;if H<0 or H>31 or I<0 or H+I>32 then error'out of range'end;w=w%c;return J(w,H,...)end;function a.bit32.replace(w,j,H,...)local I=...or 1;if H<0 or H>31 or I<0 or H+I>32 then error'out of range'end;w=w%c;j=j%c;return M(w,j,H,...)end;a.bit={}function a.bit.tobit(w)w=w%c;if w>=0x80000000 then w=w-c end;return w end;local _=a.bit.tobit;function a.bit.tohex(w,...)return G(w%c,...)end;function a.bit.bnot(w)return _(y(w%c))end;local function a0(n,o,N,...)if N then return a0(a0(n,o),N,...)elseif o then return _(A(n%c,o%c))else return _(n)end end;a.bit.bor=a0;local function a1(n,o,N,...)if N then return a1(a1(n,o),N,...)elseif o then return _(z(n%c,o%c))else return _(n)end end;a.bit.band=a1;local function a2(n,o,N,...)if N then return a2(a2(n,o),N,...)elseif o then return _(x(n%c,o%c))else return _(n)end end;a.bit.bxor=a2;function a.bit.lshift(w,E)return _(B(w%c,E%32))end;function a.bit.rshift(w,E)return _(C(w%c,E%32))end;function a.bit.arshift(w,E)return _(U(w%c,E%32))end;function a.bit.rol(w,E)return _(S(w%c,E%32))end;function a.bit.ror(w,E)return _(R(w%c,E%32))end;function a.bit.bswap(w)return _(P(w%c))end;return a end)()local unpack=table.unpack or unpack;local a3;local a4;local a5;local a6=50;local a7={[22]=18,[31]=8,[33]=28,[0]=3,[1]=13,[2]=23,[26]=33,[12]=1,[13]=6,[14]=10,[15]=16,[16]=20,[17]=26,[18]=30,[19]=36,[3]=0,[4]=2,[5]=4,[6]=7,[7]=9,[8]=12,[9]=14,[10]=17,[20]=19,[21]=22,[23]=24,[24]=27,[25]=29,[27]=32,[32]=34,[34]=37,[11]=5,[28]=11,[29]=15,[30]=21,[35]=25,[36]=31,[37]=35}local a8={[0]='ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local a9={[0]={b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgR'},{b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgU'},{b='OpArgR',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgN',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgN',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgU',c='OpArgN'}}local function aa(ab,s,e,d)local ac=0;for i=s,e,d do ac=ac+string.byte(ab,i,i)*256^(i-s)end;return ac end;local function ad(ae,af,ag,ah)local ai=(-1)^bit.rshift(ah,7)local aj=bit.rshift(ag,7)+bit.lshift(bit.band(ah,0x7F),1)local ak=ae+bit.lshift(af,8)+bit.lshift(bit.band(ag,0x7F),16)local al=1;if aj==0 then if ak==0 then return ai*0 else al=0;aj=1 end elseif aj==0x7F then if ak==0 then return ai*1/0 else return ai*0/0 end end;return ai*2^(aj-127)*(1+al/2^23)end;local function am(ae,af,ag,ah,an,ao,ap,aq)local ai=(-1)^bit.rshift(aq,7)local aj=bit.lshift(bit.band(aq,0x7F),4)+bit.rshift(ap,4)local ak=bit.band(ap,0x0F)*2^48;local al=1;ak=ak+ao*2^40+an*2^32+ah*2^24+ag*2^16+af*2^8+ae;if aj==0 then if ak==0 then return ai*0 else al=0;aj=1 end elseif aj==0x7FF then if ak==0 then return ai*1/0 else return ai*0/0 end end;return ai*2^(aj-1023)*(al+ak/2^52)end;local function ar(ab,s,e)return aa(ab,s,e-1,1)end;local function as(ab,s,e)return aa(ab,e-1,s,-1)end;local function at(ab,s)return ad(string.byte(ab,s,s+3))end;local function au(ab,s)local ae,af,ag,ah=string.byte(ab,s,s+3)return ad(ah,ag,af,ae)end;local function av(ab,s)return am(string.byte(ab,s,s+7))end;local function aw(ab,s)local ae,af,ag,ah,an,ao,ap,aq=string.byte(ab,s,s+7)return am(aq,ap,ao,an,ah,ag,af,ae)end;local ax={[4]={little=at,big=au},[8]={little=av,big=aw}}local function ay(S)local az=S.index;local aA=string.byte(S.source,az,az)S.index=az+1;return aA end;local function aB(S,aC)local aD=S.index+aC;local aE=string.sub(S.source,S.index,aD-1)S.index=aD;return aE end;local function aF(S)local aC=S:s_szt()local aE;if aC~=0 then aE=string.sub(aB(S,aC),1,-2)end;return aE end;local function aG(aC,aH)return function(S)local aD=S.index+aC;local aI=aH(S.source,S.index,aD)S.index=aD;return aI end end;local function aJ(aC,aH)return function(S)local aK=aH(S.source,S.index)S.index=S.index+aC;return aK end end;local function aL(S)local aM=S:s_int()local aN={}for i=1,aM do local aO=S:s_ins()local aP=bit.band(aO,0x3F)local aQ=a8[aP]local aR=a9[aP]local aS={value=aO,op=a7[aP],A=bit.band(bit.rshift(aO,6),0xFF)}if aQ=='ABC'then aS.B=bit.band(bit.rshift(aO,23),0x1FF)aS.C=bit.band(bit.rshift(aO,14),0x1FF)aS.is_KB=aR.b=='OpArgK'and aS.B>0xFF;aS.is_KC=aR.c=='OpArgK'and aS.C>0xFF elseif aQ=='ABx'then aS.Bx=bit.band(bit.rshift(aO,14),0x3FFFF)aS.is_K=aR.b=='OpArgK'elseif aQ=='AsBx'then aS.sBx=bit.band(bit.rshift(aO,14),0x3FFFF)-131071 end;aN[i]=aS end;return aN end;local function aT(S)local aM=S:s_int()local aU={}for i=1,aM do local aV=ay(S)local k;if aV==1 then k=ay(S)~=0 elseif aV==3 then k=S:s_num()elseif aV==4 then k=aF(S)end;aU[i]=k end;return aU end;local function aW(S,ab)local aM=S:s_int()local aX={}for i=1,aM do aX[i]=a5(S,ab)end;return aX end;local function aY(S)local aM=S:s_int()local aZ={}for i=1,aM do aZ[i]=S:s_int()end;return aZ end;local function a_(S)local aM=S:s_int()local b0={}for i=1,aM do b0[i]={varname=aF(S),startpc=S:s_int(),endpc=S:s_int()}end;return b0 end;local function b1(S)local aM=S:s_int()local b2={}for i=1,aM do b2[i]=aF(S)end;return b2 end;function a5(S,b3)local b4={}local ab=aF(S)or b3;b4.source=ab;S:s_int()S:s_int()b4.numupvals=ay(S)b4.numparams=ay(S)ay(S)ay(S)b4.code=aL(S)b4.const=aT(S)b4.subs=aW(S,ab)b4.lines=aY(S)a_(S)b1(S)for _,v in ipairs(b4.code)do if v.is_K then v.const=b4.const[v.Bx+1]else if v.is_KB then v.const_B=b4.const[v.B-0xFF]end;if v.is_KC then v.const_C=b4.const[v.C-0xFF]end end end;return b4 end;function a3(ab)local b5;local b6;local b7;local b8;local b9;local ba;local bb;local bc={index=1,source=ab}assert(aB(bc,4)=='\27Lua','invalid Lua signature')assert(ay(bc)==0x51,'invalid Lua version')assert(ay(bc)==0,'invalid Lua format')b6=ay(bc)~=0;b7=ay(bc)b8=ay(bc)b9=ay(bc)ba=ay(bc)bb=ay(bc)~=0;b5=b6 and ar or as;bc.s_int=aG(b7,b5)bc.s_szt=aG(b8,b5)bc.s_ins=aG(b9,b5)if bb then bc.s_num=aG(ba,b5)elseif ax[ba]then bc.s_num=aJ(ba,ax[ba][b6 and'little'or'big'])else error('unsupported float size')end;return a5(bc,'@virtual')end;local function bd(be,bf)for i,bg in pairs(be)do if bg.index>=bf then bg.value=bg.store[bg.index]bg.store=bg;bg.index='value'be[i]=nil end end end;local function bh(be,bf,bi)local bj=be[bf]if not bj then bj={index=bf,store=bi}be[bf]=bj end;return bj end;local function bk(...)return select('#',...),{...}end;local function bl(bm,bn)local ab=bm.source;local bo=bm.lines[bm.pc-1]local b3,bp,bq=string.match(bn,'^(.-):(%d+):%s+(.+)')local br='%s:%i: [%s:%i] %s'bo=bo or'0'b3=b3 or'?'bp=bp or'0'bq=bq or bn;error(string.format(br,ab,bo,b3,bp,bq),0)end;local function bs(bm)local aN=bm.code;local bt=bm.subs;local bu=bm.env;local bv=bm.upvals;local bw=bm.varargs;local bx=-1;local by={}local bi=bm.stack;local bz=bm.pc;while true do local bA=aN[bz]local aP=bA.op;bz=bz+1;if aP<18 then if aP<8 then if aP<3 then if aP<1 then for i=bA.A,bA.B do bi[i]=nil end elseif aP>1 then local bg=bv[bA.B]bi[bA.A]=bg.store[bg.index]else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB+bC end elseif aP>3 then if aP<6 then if aP>4 then local A=bA.A;local B=bA.B;local bf;if bA.is_KC then bf=bA.const_C else bf=bi[bA.C]end;bi[A+1]=bi[B]bi[A]=bi[B][bf]else bi[bA.A]=bu[bA.const]end elseif aP>6 then local bf;if bA.is_KC then bf=bA.const_C else bf=bi[bA.C]end;bi[bA.A]=bi[bA.B][bf]else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB-bC end else bi[bA.A]=bi[bA.B]end elseif aP>8 then if aP<13 then if aP<10 then bu[bA.const]=bi[bA.A]elseif aP>10 then if aP<12 then local A=bA.A;local B=bA.B;local C=bA.C;local bD;local bE,bF;if B==0 then bD=bx-A else bD=B-1 end;bE,bF=bk(bi[A](unpack(bi,A+1,A+bD)))if C==0 then bx=A+bE-1 else bE=C-1 end;for i=1,bE do bi[A+i-1]=bF[i]end else local bg=bv[bA.B]bg.store[bg.index]=bi[bA.A]end else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB*bC end elseif aP>13 then if aP<16 then if aP>14 then local A=bA.A;local B=bA.B;local bD;if B==0 then bD=bx-A else bD=B-1 end;bd(by,0)return bk(bi[A](unpack(bi,A+1,A+bD)))else local bf,bG;if bA.is_KB then bf=bA.const_B else bf=bi[bA.B]end;if bA.is_KC then bG=bA.const_C else bG=bi[bA.C]end;bi[bA.A][bf]=bG end elseif aP>16 then bi[bA.A]={}else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB/bC end else bi[bA.A]=bA.const end else local A=bA.A;local bH=bi[A+2]local bf=bi[A]+bH;local bI=bi[A+1]local bJ;if bH==math.abs(bH)then bJ=bf<=bI else bJ=bf>=bI end;if bJ then bi[bA.A]=bf;bi[bA.A+3]=bf;bz=bz+bA.sBx end end elseif aP>18 then if aP<28 then if aP<23 then if aP<20 then bi[bA.A]=#bi[bA.B]elseif aP>20 then if aP<22 then local A=bA.A;local B=bA.B;local bK={}local aM;if B==0 then aM=bx-A+1 else aM=B-1 end;for i=1,aM do bK[i]=bi[A+i-1]end;bd(by,0)return aM,bK else local aE=bi[bA.B]for i=bA.B+1,bA.C do aE=aE..bi[i]end;bi[bA.A]=aE end else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB%bC end elseif aP>23 then if aP<26 then if aP>24 then bd(by,bA.A)else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;if bB==bC==(bA.A~=0)then bz=bz+aN[bz].sBx end;bz=bz+1 end elseif aP>26 then local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;if bB<bC==(bA.A~=0)then bz=bz+aN[bz].sBx end;bz=bz+1 else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB^bC end else bi[bA.A]=bA.B~=0;if bA.C~=0 then bz=bz+1 end end elseif aP>28 then if aP<33 then if aP<30 then local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;if bB<=bC==(bA.A~=0)then bz=bz+aN[bz].sBx end;bz=bz+1 elseif aP>30 then if aP<32 then local aX=bt[bA.Bx+1]local bL=aX.numupvals;local bM;if bL~=0 then bM={}for i=1,bL do local bN=aN[bz+i-1]if bN.op==a7[0]then bM[i-1]=bh(by,bN.B,bi)elseif bN.op==a7[4]then bM[i-1]=bv[bN.B]end end;bz=bz+bL end;bi[bA.A]=a4(aX,bu,bM)else local A=bA.A;local B=bA.B;if not bi[B]==(bA.C~=0)then bz=bz+1 else bi[A]=bi[B]end end else bi[bA.A]=-bi[bA.B]end elseif aP>33 then if aP<36 then if aP>34 then local A=bA.A;local aM=bA.B;if aM==0 then aM=bw.size;bx=A+aM-1 end;for i=1,aM do bi[A+i-1]=bw.list[i]end else local A=bA.A;local bO,bI,bH;bO=assert(tonumber(bi[A]),'`for` initial value must be a number')bI=assert(tonumber(bi[A+1]),'`for` limit must be a number')bH=assert(tonumber(bi[A+2]),'`for` step must be a number')bi[A]=bO-bH;bi[A+1]=bI;bi[A+2]=bH;bz=bz+bA.sBx end elseif aP>36 then local A=bA.A;local C=bA.C;local aM=bA.B;local bP=bi[A]local bQ;if aM==0 then aM=bx-A end;if C==0 then C=bA[bz].value;bz=bz+1 end;bQ=(C-1)*a6;for i=1,aM do bP[i+bQ]=bi[A+i]end else bi[bA.A]=not bi[bA.B]end else if not bi[bA.A]==(bA.C~=0)then bz=bz+1 end end else local A=bA.A;local aH=bi[A]local bR=bi[A+1]local bf=bi[A+2]local bS=A+3;local bK;bi[bS+2]=bf;bi[bS+1]=bR;bi[bS]=aH;bK={aH(bR,bf)}for i=1,bA.C do bi[bS+i-1]=bK[i]end;if bi[bS]~=nil then bi[A+2]=bi[bS]else bz=bz+1 end end else bz=bz+bA.sBx end;bm.pc=bz end end;function a4(bR,bu,b2)local bT=bR.code;local bU=bR.subs;local bV=bR.lines;local bW=bR.source;local bX=bR.numparams;local function bY(...)local bi={}local bZ={}local b_=0;local c0,c1=bk(...)local bm;local c2,bn,bK;for i=1,bX do bi[i-1]=c1[i]end;if bX<c0 then b_=c0-bX;for i=1,b_ do bZ[i]=c1[bX+i]end end;bm={varargs={list=bZ,size=b_},code=bT,subs=bU,lines=bV,source=bW,env=bu,upvals=b2,stack=bi,pc=1}c2,bn,bK=pcall(bs,bm,...)if c2 then return unpack(bK,1,bn)else bl(bm,bn)end;return end;return bY end;return function(c3,bu)return a4(a3(c3),bu or fev(0))end end)()]==],
	AES = nil,
	AESCode = [==[(function()local function a(b)local c={}for d=0,255 do c[d]={}end;c[0][0]=b[1]*255;local e=1;for f=0,7 do for d=0,e-1 do for g=0,e-1 do local h=c[d][g]-b[1]*e;c[d][g+e]=h+b[2]*e;c[d+e][g]=h+b[3]*e;c[d+e][g+e]=h+b[4]*e end end;e=e*2 end;return c end;local i=a{0,1,1,0}local function j(self,k)local l,d,g=self.S,self.i,self.j;local m={}local n=string.char;for o=1,k do d=(d+1)%256;g=(g+l[d])%256;l[d],l[g]=l[g],l[d]m[o]=n(l[(l[d]+l[g])%256])end;self.i,self.j=d,g;return table.concat(m)end;local function p(self,q)local r=j(self,#q)local s={}local t=string.byte;local n=string.char;for d=1,#q do s[d]=n(i[t(q,d)][t(r,d)])end;return table.concat(s)end;local function u(self,v)local l=self.S;local g,w=0,#v;local t=string.byte;for d=0,255 do g=(g+l[d]+t(v,d%w+1))%256;l[d],l[g]=l[g],l[d]end end;function new(v)local l={}local s={S=l,i=0,j=0,generate=j,cipher=p,schedule=u}for d=0,255 do l[d]=d end;if v then s:schedule(v)end;return s end;return new end)()]==],
	Base64 = {
		Encode = function(a)local b=charset;return(a:gsub('.',function(c)local d,b='',c:byte()for e=8,1,-1 do d=d..(b%2^e-b%2^(e-1)>0 and'1'or'0')end;return d end)..'0000'):gsub('%d%d%d?%d?%d?%d?',function(c)if#c<6 then return''end;local f=0;for e=1,6 do f=f+(c:sub(e,e)=='1'and 2^(6-e)or 0)end;return b:sub(f+1,f+1)end)..({'','==','='})[#a%3+1]end,
		Decode = function(a)local b=charset;a=string.gsub(a,'[^'..b..'=]','')return a:gsub('.',function(c)if c=='='then return''end;local d,e='',b:find(c)-1;for f=6,1,-1 do d=d..(e%2^f-e%2^(f-1)>0 and'1'or'0')end;return d end):gsub('%d%d%d?%d?%d?%d?%d?%d?',function(c)if#c~=8 then return''end;local g=0;for f=1,8 do g=g+(c:sub(f,f)=='1'and 2^(8-f)or 0)end;return string.char(g)end)end
	},
	Base64Code = {
		Encode = [==[function(a)local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';return(a:gsub('.',function(c)local d,b='',c:byte()for e=8,1,-1 do d=d..(b%2^e-b%2^(e-1)>0 and'1'or'0')end;return d end)..'0000'):gsub('%d%d%d?%d?%d?%d?',function(c)if#c<6 then return''end;local f=0;for e=1,6 do f=f+(c:sub(e,e)=='1'and 2^(6-e)or 0)end;return b:sub(f+1,f+1)end)..({'','==','='})[#a%3+1]end]==],
		Decode = [==[function(a)local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';a=string.gsub(a,'[^'..b..'=]','')return a:gsub('.',function(c)if c=='='then return''end;local d,e='',b:find(c)-1;for f=6,1,-1 do d=d..(e%2^f-e%2^(f-1)>0 and'1'or'0')end;return d end):gsub('%d%d%d?%d?%d?%d?%d?%d?',function(c)if#c~=8 then return''end;local g=0;for f=1,8 do g=g+(c:sub(f,f)=='1'and 2^(8-f)or 0)end;return string.char(g)end)end]==]
	},
};

--Resources:
-- Compiler: Yueliang(source, scriptname): luac string | Executor: FiOne(luac, env): function
-- Base64: Base64.Encode(data): string | Base64.Decode(data): string
-- "FiOneCode" loadstringable string
-- AES: AES(key) - and something
-- AESCode: src of aes
-- Base64Code: src of base64 Encode, Decode
--
function loaddata(name)
	return resources[name]
end

local compile = loaddata("Yueliang")
local execute = loaddata("FiOne")

local loadstring_ = loadstring
do
	loadstring = function(contents, chunkname, env) -- wow custom loadstring
		local bytecode = compile(contents, chunkname or nil)
		local func = execute(bytecode, env or fenv(2))
		return func
	end
	resources.AES = loadstring("return " .. loaddata("AESCode"))()
end

local _settings = { -- default options
	comment = "// CRYPTED", -- "--'comment'"
	variablecomment = "lol you have to stop trying to deobfuscate",
	cryptvarcomment = true, -- encrypt variablecomment with bytecode
	variablename = "CRYPTED", -- "local 'variablename' = 'variablecomment' or something"
}

local aes = loaddata("AES")
local base64 = loaddata("Base64")
local function aesenc(code, key)
	local state = aes(key)
	local unable = state:cipher(code)
	local able = base64.Encode(unable)
	return able
end

local function aesdec(code, key)
	local state = aes(key)
	local unable = base64.Decode(code)
	local result = state:cipher(unable)
	return result
end

local function genpass(l)
	local pass = ""
	for i = 1, l do
		local a = math.random(1,#morecharset)
		pass = pass .. morecharset:sub(a,a)
	end
	return pass
end

local h2b = {
	['0']='0000', ['1']='0001', ['2']='0010', ['3']='0011',
	['4']='0100', ['5']='0101', ['6']='0110', ['7']='0111',
	['8']='1000', ['9']='1001', ['A']='1010', ['B']='1011',
	['C']='1100', ['D']='1101', ['E']='1110', ['F']='1111'
}
local function d2b(n)
	return ('%X'):format(n):upper():gsub(".", h2b)
end
local function genIl(a)
	return d2b((a):byte(1,-1)):gsub("0","l"):gsub("1","I") 
end

M.crypt = function(source, options)
	options = options or {}
	for k,v in pairs(_settings) do
		if options[k] == nil then
			options[k] = v
		end
	end
	options.variablename = options.variablename:gsub('[%p%c%s]', '_')
	options.variablename = options.variablename:sub(1,1):gsub('[%d]','v'..options.variablename:sub(1,1)) .. options.variablename:sub(2)
	local varname = options.variablename
	local varcomment = options.cryptvarcomment and "\\"..table.concat({options.variablecomment:byte(1,-1)},"\\") or options.variablecomment
	local comment = options.comment

	-- f%d_%a -- fake
	-- c%d_%a -- real
	print("Obfuscating | Code conversion...")
	local succ, luac = pcall(function()
		return compile(source, "gg_y")
	end)
	if succ == false then
		print("Lua Error")
		return error(luac)
	end
	print("Obfuscating | Encrypting...")
	local r_key = "return (function()"
	local fv_z = ("local %s%s = \"%s\";"):format(varname, genIl("z"), varcomment)
	local f1_a = ("local %s%s"):format(varname, genIl("a"))
	local f2_b = ("local %s%s"):format(varname, genIl("b"))
	local f3_c = ("local %s%s"):format(varname, genIl("c"))
	local c1_d = ("local %s%s"):format(varname, genIl("d"))
	local f4_e = ("local %s%s"):format(varname, genIl("e"))
	local f5_f = ("local %s%s"):format(varname, genIl("f"))
	local f6_g = ("local %s%s"):format(varname, genIl("g"))
	local passkey = genpass(math.random(10,20))
	local encsrc = aesenc(base64.Encode(luac), passkey)
	local key64 = base64.Encode(passkey)
	print("Obfuscating | Code Building...")
	local f4 = f4_e .. "=" .. ("'%s'"):format(base64.Encode(genpass(math.random(10,20))))
	local f5 = f5_f .. "=" .. ("'%s'"):format(varcomment)
	local f6 = f6_g .. "=" .. ("'%s'"):format(base64.Encode(genpass(math.random(10,20))))
	local c1 = c1_d .. "=" .. ("'%s'"):format("\\"..table.concat({key64:byte(1,-1)},"\\"))
	local fks = {f4,f5,f6,c1}
	local i_ = ("%s%s"):format(varname, genIl("i"))
	local c2_i_b64 = ("local %s"):format(i_) .. "=" .. loaddata("Base64Code").Decode
	local j_ = ("%s%s"):format(varname, genIl("j"))
	local c3_j_aes = ("local %s"):format(j_) .. "=" .. loaddata("AESCode")
	local k_ = ("%s%s"):format(varname, genIl("k"))
	local c4_k_fne = ("local %s"):format(k_) .. "=" .. loaddata("FiOneCode")
	local f7_h = [[function ]]..("%s%s"):format(varname, genIl("h"))..[[(a,b)local c=]]..i_..[[(a,b);local d=]]..f4_e:sub(7)..[[;return c,d end]]
	local f8_l = ("%s%s"):format(varname, genIl("h"))..("(%s,%d)"):format(f5_f:sub(7),math.random(314,31415))
	local m_ = ("%s%s"):format(varname, genIl("m"))
	local c4_m = ("local %s"):format(m_) .. "=" .. "function(a,b)" ..--a.64key,b.64src
		"local c="..j_.."("..i_.."(a))" ..
		"local d=c[\"\\99\\105\\112\\104\\101\\114\"](c,"..i_.."(b))" ..
		"return "..i_.."(d)" ..
		"end"
	local n_ = ("%s%s"):format(varname, genIl("n"))
	local bytedsrc = nil
	if encsrc:len() > 255 then -- handle lua byte library limit
		local chunkedbys = {}
		for i=1,#encsrc,255 do
			chunkedbys[#chunkedbys+1] = {encsrc:sub(i,i+255 - 1):byte(1,-1)}
		end
		bytedsrc = {}
		for i,v in pairs(chunkedbys) do
			for i1,v1 in pairs(v) do
				bytedsrc[#bytedsrc+1] = v1
			end
		end
	else
		bytedsrc = {encsrc:byte(1,-1)}
	end
	local c5res = "\\"..table.concat(bytedsrc,"\\")
	local c5_n = ("local %s"):format(n_) .. "="..("\"%s\""):format(c5res)
	local fenvhandle = "local fev=getfenv or function()return _ENV end"
	local f9_o = ("local %s%s"):format(varname, genIl("o")) .. "=" .. ("'%s%s%s'"):format(base64.Encode(genpass(math.random(10,20))),base64.Encode(genpass(math.random(10,20))),base64.Encode(genpass(math.random(10,20))))
	local c_end = ("return %s(%s(%s,%s),getfenv(0))()end)()"):format(k_,m_,(c1_d):sub(7),n_)--1.exe,2.c4,3.c4_a,4.c4_b
	print("Obfuscated!")
	return "--" .. comment .. "\n\n" ..
		r_key ..
		fv_z ..
		fv_z ..
		fv_z ..
		f1_a .. "=" .. ("%d"):format(math.random(111,31415)/100) .. ";" ..
		f2_b .. "=" .. ("%d"):format(math.random(111,31415)/100) .. ";" ..
		f3_c .. "=" .. ("%d"):format(math.pi) .. ";" ..
		c2_i_b64 ..  ";" ..
		f2_b .. "=" .. ("%d"):format(math.random(111,31415)/100) .. ";" ..
		c3_j_aes ..  ";" ..
		fenvhandle .. ";" ..
		c4_k_fne .. ";" ..
		fks[math.random(1,#fks)] .. ";" ..
		c5_n .. ";" ..
		fks[math.random(1,#fks)] .. ";" ..
		fks[math.random(1,#fks)] .. ";" ..
		c4_m .. ";" ..
		fks[math.random(1,#fks)] .. ";" ..
		c1 .. ";" ..
		fks[math.random(1,#fks)] .. ";" ..
		f9_o .. ";" ..
		f7_h .. ";" ..
		c_end
end

if climode == true then
	local rsuccess, readdfile, rerr = pcall(function()
		return io.open(realargs.source, "rb")
	end)
	if rsuccess == false or readdfile == nil then
		print("File (source file) Reading Error: " .. (rsuccess == false and readdfile or rerr or "Unknown"))
		return
	end
	print(("Selected source file to \"%s\"."):format(realargs.source))
	local wsuccess, wdfile, werr = pcall(function()
		return io.open(realargs.output or "output.lua", "w")
	end)
	if wsuccess == false or wdfile == nil then
		readdfile:close()
		print("File (output file) Writing Error: " .. (wsuccess == false and wdfile or werr or "Unknown"))
		return
	end
	print(("Selected output file to \"%s\"."):format(realargs.output or "output.lua"))
	local clisettings = {
		comment = realargs.comment or _settings.comment, -- --comment "string"
		variablecomment = realargs.varcomm or _settings.variablecomment, -- --varcomm "string"
		cryptvarcomment = realargs.cryptvarcomm or false, -- --cryptvarcomm
		variablename = realargs.varname or _settings.variablename, -- --varname "string"
	}
	local starttime = os.clock()
	print("Starting obfuscation.")
	local kb = M.crypt(readdfile:read("*a"),clisettings) -- you need more memory if you get error at here
	print(("Finished obfuscation in %d seconds."):format(os.clock() - starttime))
	readdfile:close()
	wdfile:write(kb)
	wdfile:close()
	kb = nil
	print(("Obfuscated code are written to \"%s\"."):format(realargs.output or "output.lua"))
	print("All done.")
	return
end

return setmetatable(M, {
	__call = function(self, source, options)
		return self.crypt(source, options)
	end,
})
